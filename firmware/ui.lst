   1               		.file	"ui.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.text
   7               	.Ltext0:
   8               		.cfi_sections	.debug_frame
   9               		.section	.rodata.str1.1,"aMS",@progbits,1
  10               	.LC0:
  11 0000 3A2D 2900 		.string	":-)"
  12               		.text
  13               	.global	printMenu
  15               	printMenu:
  16               	.LFB1:
  17               		.file 1 "ui.c"
   1:ui.c          **** /******************************************************************************
   2:ui.c          **** Created 26 Nov 2012 by Mike Hord at SparkFun Electronics.
   3:ui.c          **** Wake-on-Shake hardware and firmware are released under the Creative Commons 
   4:ui.c          **** Share Alike v3.0 license:
   5:ui.c          **** 	http://creativecommons.org/licenses/by-sa/3.0/
   6:ui.c          **** Feel free to use, distribute, and sell variants of Wake-on-Shake. All we ask 
   7:ui.c          **** is that you include attribution of 'Based on Wake-on-Shake by SparkFun'.
   8:ui.c          **** 
   9:ui.c          **** ui.cpp
  10:ui.c          **** This file contains implementations of the various user interface functionality.
  11:ui.c          **** Primarily, it contains a very large state machine for parsing data received
  12:ui.c          **** across the serial port into commands.
  13:ui.c          **** ******************************************************************************/
  14:ui.c          **** 
  15:ui.c          **** #include<avr/io.h>
  16:ui.c          **** #include "ui.h"
  17:ui.c          **** #include "wake-on-shake.h"
  18:ui.c          **** #include "eeprom.h"
  19:ui.c          **** #include "serial.h"
  20:ui.c          **** #include "ADXL362.h"
  21:ui.c          **** 
  22:ui.c          **** extern uint16_t				t1Offset;		// see Wake-on-Shake.cpp
  23:ui.c          **** extern volatile uint8_t		serialRxData;	// see Wake-on-Shake.cpp
  24:ui.c          **** 
  25:ui.c          **** // Probably the most complex part of the code, serialParse() is a state machine
  26:ui.c          **** //   which provides a limited user interface for setting and getting the parameters
  27:ui.c          **** //   which dictate the operation of the Wake-on-shake. It gets called by the main
  28:ui.c          **** //   code whenever a serial interrupt receives a non-null value over the serial
  29:ui.c          **** //   port. It echoes back the received data (primarily for user convenience), then
  30:ui.c          **** //   handles the data depending on current state and received data.
  31:ui.c          **** void serialParse(void)
  32:ui.c          **** {
  33:ui.c          **** 	// Static variables- these need to persist between calls to this function.
  34:ui.c          **** 	
  35:ui.c          **** 	// inputBufferValue is the number that the user is currently entering in-
  36:ui.c          **** 	//  it could be a threshold value, a delay value, a value to be written
  37:ui.c          **** 	//  to the ADXL362 or into EEPROM, or something else. We parse it in by
  38:ui.c          **** 	//  multiplying the old value by ten and adding the recently received value
  39:ui.c          **** 	//  to the previous value, so we need the current value to persist between
  40:ui.c          **** 	//  calls.
  41:ui.c          **** 	static uint16_t		inputBufferValue = 0;
  42:ui.c          **** 	// mode lets the function know how it should respond to data. In some cases,
  43:ui.c          **** 	//   we just want to keep incrementing inputBufferValue; in others, we want
  44:ui.c          **** 	//   to take immediate action.
  45:ui.c          **** 	static uint8_t		mode = ' ';
  46:ui.c          **** 	// serialDataBuffer is used to store a value the user wants to either send
  47:ui.c          **** 	//   to the ADXL362 or put into EEPROM. For ease of implementation, we only
  48:ui.c          **** 	//   do one byte at a time- first put in the data, then tell the device
  49:ui.c          **** 	//   where to send it.
  50:ui.c          **** 	static uint8_t		serialDataBuffer = 0;
  51:ui.c          **** 	// localData buffers serialRxData. Because of the length of time it can
  52:ui.c          **** 	//   take for this function to complete (at 2400 baud, serial writes take
  53:ui.c          **** 	//   quite some time, as do EEPROM writes), we want to know that nothing
  54:ui.c          **** 	//   has changed between when we enter the function and code we encounter
  55:ui.c          **** 	//   further down. The only way to ensure that is to buffer serialRxData
  56:ui.c          **** 	//   locally, since serialRxData can be changed by the serial receive ISR
  57:ui.c          **** 	//   at any time.
  58:ui.c          **** 	uint8_t				localData = serialRxData;
  59:ui.c          **** 	
  60:ui.c          **** 	serialRxData = 0;					// Clear serialRxData
  61:ui.c          **** 	//serialWriteChar(localData);		// Echo received data. Removed from
  62:ui.c          **** 										//  released version b/c there's no
  63:ui.c          **** 										//  real need to do this.
  64:ui.c          **** 	
  65:ui.c          **** // The state machine is implemented as an if/else group.
  66:ui.c          **** 	
  67:ui.c          **** // First case: carriage returns/newlines when we're in the "no data" state.
  68:ui.c          **** //   Basically, we can just ignore these. This is important, because we don't
  69:ui.c          **** //   know for sure what the serial program the user is entering data from will
  70:ui.c          **** //   send at the end of the line, so we need to respond to either if they
  71:ui.c          **** //   happen at the end of data entry, and ignore them any other time, since
  72:ui.c          **** //   some programs may send BOTH CR and LF. We also don't want to let this be
  73:ui.c          **** //   the default case, because it would be annoying to see "Invalid input"
  74:ui.c          **** //   every time we enter a value.
  75:ui.c          **** 	if (((localData == '\n') | (localData == '\r')) & (mode == ' '));
  76:ui.c          **** 	
  77:ui.c          **** // CR/LF when we're in data reading mode: respond to whichever one happens first
  78:ui.c          **** //   by parsing the received data.
  79:ui.c          **** 	else if (((localData == '\n') | (localData == '\r')) & (mode != ' '))
  80:ui.c          **** 	{
  81:ui.c          **** 		// Now, make a decision about what to do with the data depending on the mode.
  82:ui.c          **** 		switch(mode)
  83:ui.c          **** 		{
  84:ui.c          **** 			// 't' indicates that user wanted to change the threshold setting, so
  85:ui.c          **** 			//   let's store the inputBufferValue in EEPROM and update the value in
  86:ui.c          **** 			//   memory. We won't bother updating the ADXL362 just yet; that will
  87:ui.c          **** 			//   happen right before we go to sleep.
  88:ui.c          **** 			case 't':
  89:ui.c          **** 			EEPROMWriteWord((uint8_t)ATHRESH, inputBufferValue);
  90:ui.c          **** 			break;
  91:ui.c          **** 			// 'd' indicates that user wanted to change the delay before sleep, so
  92:ui.c          **** 			//   so we need to convert the user's value in milliseconds to an offset
  93:ui.c          **** 			//   value that can be loaded into TCNT1. We'll also include a check so
  94:ui.c          **** 			//   the user can't accidentally set the timeout period so short as to
  95:ui.c          **** 			//   render the device difficult to program.
  96:ui.c          **** 			case 'd':
  97:ui.c          **** 			t1Offset = 65535 - inputBufferValue;
  98:ui.c          **** 			if (t1Offset > 63535) t1Offset = 63535;
  99:ui.c          **** 			EEPROMWriteWord((uint8_t)WAKE_OFFS, t1Offset);
 100:ui.c          **** 			break;
 101:ui.c          **** 			// 'b' indicates that the user wishes to buffer a value to be written
 102:ui.c          **** 			//   to something, either the ADXL362 -or- an EEPROM location in the tiny.
 103:ui.c          **** 			case 'b':
 104:ui.c          **** 			serialDataBuffer = (uint8_t)inputBufferValue;
 105:ui.c          **** 			break;
 106:ui.c          **** 			// 'w' indicates that the user wants to write a value directly to the
 107:ui.c          **** 			//   ADXL362 part. In this case, inputBufferValue is taken as an
 108:ui.c          **** 			//   address to write to, and the data to be written is in the
 109:ui.c          **** 			//   serialDataBuffer variable.
 110:ui.c          **** 			case 'w':
 111:ui.c          **** 			ADXLWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
 112:ui.c          **** 			break;
 113:ui.c          **** 			// 'r' indicates a desire to read from an address in the ADXL part.
 114:ui.c          **** 			//   inputBufferValue provides an address to read from.
 115:ui.c          **** 			case 'r':
 116:ui.c          **** 			serialWriteInt((uint16_t)ADXLReadByte((uint8_t)inputBufferValue));
 117:ui.c          **** 			break;
 118:ui.c          **** 			// 'e' directs the device to store the buffered value into the
 119:ui.c          **** 			//   address provided by inputBufferValue.
 120:ui.c          **** 			case 'e':
 121:ui.c          **** 			EEPROMWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
 122:ui.c          **** 			break;
 123:ui.c          **** 			// 'E' directs the device to return a value stored in the EEPROM
 124:ui.c          **** 			//   over the serial port from the address specified.
 125:ui.c          **** 			case 'E':
 126:ui.c          **** 			serialWriteInt((uint16_t)EEPROMReadByte((uint8_t)inputBufferValue));
 127:ui.c          **** 			break;
 128:ui.c          **** 		}
 129:ui.c          **** 		inputBufferValue = 0;		// Clear the input buffer for next data stream.
 130:ui.c          **** 		mode = ' ';					// Reset the mode for next data stream.
 131:ui.c          **** 		printMenu();				// Just an indicator of success.
 132:ui.c          **** 	}
 133:ui.c          **** 	
 134:ui.c          **** // If the mode is currently null, and the character entered is a valid mode,
 135:ui.c          **** //   let's activate that mode. In some cases, we want immediate action, and
 136:ui.c          **** //   then to return to null mode.
 137:ui.c          **** 	else if ((mode == ' ')&(
 138:ui.c          **** 			(localData == 't') |	// Change the threshold setting
 139:ui.c          **** 			(localData == 'd') |	// Change the delay before sleep
 140:ui.c          **** 			(localData == 'z') |	// Force sleep in ~35ms
 141:ui.c          **** 			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
 142:ui.c          **** 			(localData == 'w') |	// Write buffered byte to ADXL362 register
 143:ui.c          **** 			(localData == 'r') |	// Read ADXL362 register
 144:ui.c          **** 			(localData == 'e') |	// Write buffered byte to EEPROM address
 145:ui.c          **** 			(localData == 'E') |	// Read byte from EEPROM address
 146:ui.c          **** 			(localData == 'p') |	// Read pin level (pins on header only)
 147:ui.c          **** 			(localData == 'H') |	// Set pin high (pins on header only)
 148:ui.c          **** 			(localData == 'L')		// Set pin low (pins on header only)
 149:ui.c          **** 			))
 150:ui.c          **** 	{
 151:ui.c          **** 		mode = localData;
 152:ui.c          **** 		// Most of the time, we need more information from the user. SOMETIMES,
 153:ui.c          **** 		//   we may want to take immediate action. ATM, only a 'z' spurs that,
 154:ui.c          **** 		//   indicating to the device that we want it to go to sleep post-haste
 155:ui.c          **** 		//   and not buffer more data. Future immediate commands should be
 156:ui.c          **** 		//   added here.
 157:ui.c          **** 	    if (mode == 'z')
 158:ui.c          **** 		{
 159:ui.c          **** 			TCNT1 = 65500;	// Set TCNT1 to *almost* overflowing. Sleep will
 160:ui.c          **** 							//   occur right after an overflow of TCNT1.
 161:ui.c          **** 			mode = ' ';		// Clear mode for later.
 162:ui.c          **** 		}
 163:ui.c          **** 	}
 164:ui.c          **** // Mode handler. Depending on the mode, the current input character should
 165:ui.c          **** //   be handled differently. Code for handling what happens before a user
 166:ui.c          **** //   has finished inputting a number goes here.
 167:ui.c          **** 	else if (	(mode == 't')|\
 168:ui.c          **** 				(mode == 'd')|\
 169:ui.c          **** 				(mode == 'w')|\
 170:ui.c          **** 				(mode == 'r')|\
 171:ui.c          **** 				(mode == 'e')|\
 172:ui.c          **** 				(mode == 'E')|\
 173:ui.c          **** 				(mode == 'p')|\
 174:ui.c          **** 				(mode == 'H')|\
 175:ui.c          **** 				(mode == 'L')|\
 176:ui.c          **** 				(mode == 'b'))
 177:ui.c          **** 	{
 178:ui.c          **** 		// case 'p': indicates user wants to print out the state of a given
 179:ui.c          **** 		//   pin. Pins available for this are PB0:3 and PD6; we'll respond
 180:ui.c          **** 		//   based on a numerical input 0-3 or 6. Other values print an
 181:ui.c          **** 		//   error message. Note that no cr/lf is needed to complete this
 182:ui.c          **** 		//   operation- it just...ends, as soon as another character has
 183:ui.c          **** 		//   been received.
 184:ui.c          **** 		if (mode == 'p')
 185:ui.c          **** 		{
 186:ui.c          **** 			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 187:ui.c          **** 			switch(localData)
 188:ui.c          **** 			{
 189:ui.c          **** 				case '0':
 190:ui.c          **** 				DDRB &= ~(1<<PB0);							// make pin input
 191:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB0))>>PB0));    // isolate bit and
 192:ui.c          **** 														    //   read it out
 193:ui.c          **** 				break;
 194:ui.c          **** 				case '1':
 195:ui.c          **** 				DDRB &= ~(1<<PB1);
 196:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB1))>>PB1));
 197:ui.c          **** 				break;
 198:ui.c          **** 				case '2':
 199:ui.c          **** 				DDRB &= ~(1<<PB2);
 200:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB2))>>PB2));
 201:ui.c          **** 				break;
 202:ui.c          **** 				case '3':
 203:ui.c          **** 				DDRB &= ~(1<<PB3);
 204:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB3))>>PB3));
 205:ui.c          **** 				break;
 206:ui.c          **** 				case '6':
 207:ui.c          **** 				DDRD &= ~(1<<PD6);
 208:ui.c          **** 				serialWriteChar('0'+((PIND & (1<<PD6))>>PD6));
 209:ui.c          **** 				break;
 210:ui.c          **** 				default:
 211:ui.c          **** 				abortInput();
 212:ui.c          **** 				break;
 213:ui.c          **** 			}
 214:ui.c          **** 		}
 215:ui.c          **** 		// case 'H': indicates user wants to set the state of a given pin to
 216:ui.c          **** 		//   high. Pins available for this are PB0:3 and PD6; we'll respond
 217:ui.c          **** 		//   based on a numerical input 0-3 or 6. Other values print an
 218:ui.c          **** 		//   error message.
 219:ui.c          **** 		else if (mode == 'H')
 220:ui.c          **** 		{
 221:ui.c          **** 			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 222:ui.c          **** 			switch(localData)
 223:ui.c          **** 			{
 224:ui.c          **** 				case '0':
 225:ui.c          **** 				DDRB |= (1<<PB0);	// make pin an output
 226:ui.c          **** 				PORTB |= (1<<PB0);  // set pin high
 227:ui.c          **** 				break;
 228:ui.c          **** 				case '1':
 229:ui.c          **** 				DDRB |= (1<<PB1);
 230:ui.c          **** 				PORTB |= (1<<PB1);
 231:ui.c          **** 				break;
 232:ui.c          **** 				case '2':
 233:ui.c          **** 				DDRB |= (1<<PB2);
 234:ui.c          **** 				PORTB |= (1<<PB2);
 235:ui.c          **** 				break;
 236:ui.c          **** 				case '3':
 237:ui.c          **** 				DDRB |= (1<<PB3);
 238:ui.c          **** 				PORTB |= (1<<PB3);
 239:ui.c          **** 				break;
 240:ui.c          **** 				case '6':
 241:ui.c          **** 				DDRD |= (1<<PD6);
 242:ui.c          **** 				PORTD |= (1<<PD6);
 243:ui.c          **** 				break;
 244:ui.c          **** 				default:
 245:ui.c          **** 				abortInput();
 246:ui.c          **** 				break;
 247:ui.c          **** 			}
 248:ui.c          **** 		}
 249:ui.c          **** 		// case 'L': indicates user wants to set the state of a given pin to
 250:ui.c          **** 		//   low. Pins available for this are PB0:3 and PD6; we'll respond
 251:ui.c          **** 		//   based on a numerical input 0-3 or 6. Other values print an
 252:ui.c          **** 		//   error message.
 253:ui.c          **** 		else if (mode == 'L')
 254:ui.c          **** 		{
 255:ui.c          **** 			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 256:ui.c          **** 			switch(localData)
 257:ui.c          **** 			{
 258:ui.c          **** 				case '0':
 259:ui.c          **** 				DDRB |= (1<<PB0);	// make pin an output
 260:ui.c          **** 				PORTB &= ~(1<<PB0); // set pin low
 261:ui.c          **** 				break;
 262:ui.c          **** 				case '1':
 263:ui.c          **** 				DDRB |= (1<<PB1);
 264:ui.c          **** 				PORTB &= ~(1<<PB1);
 265:ui.c          **** 				break;
 266:ui.c          **** 				case '2':
 267:ui.c          **** 				DDRB |= (1<<PB2);
 268:ui.c          **** 				PORTB &= ~(1<<PB2);
 269:ui.c          **** 				break;
 270:ui.c          **** 				case '3':
 271:ui.c          **** 				DDRB |= (1<<PB3);
 272:ui.c          **** 				PORTB &= ~(1<<PB3);
 273:ui.c          **** 				break;
 274:ui.c          **** 				case '6':
 275:ui.c          **** 				DDRD |= (1<<PD6);
 276:ui.c          **** 				PORTD &= ~(1<<PD6);
 277:ui.c          **** 				break;
 278:ui.c          **** 				default:
 279:ui.c          **** 				abortInput();
 280:ui.c          **** 				break;
 281:ui.c          **** 			}
 282:ui.c          **** 		}
 283:ui.c          **** 		// Case numeric value AND some other state not involving pins-
 284:ui.c          **** 		//   store the value into input buffer.
 285:ui.c          **** 		else if (('0' <= localData) & (localData <= '9'))
 286:ui.c          **** 		{
 287:ui.c          **** 			inputBufferValue *= 10;
 288:ui.c          **** 			inputBufferValue += (localData - '0');
 289:ui.c          **** 		}
 290:ui.c          **** 		// Case ANYTHING ELSE entered by user- clear mode, and whine a bit
 291:ui.c          **** 		//   so they know the screwed up.
 292:ui.c          **** 		else
 293:ui.c          **** 		{
 294:ui.c          **** 			mode = ' ';
 295:ui.c          **** 			abortInput();
 296:ui.c          **** 		}
 297:ui.c          **** 	}
 298:ui.c          **** 	
 299:ui.c          **** // Otherwise, just ignore what's happening and go back to null mode.
 300:ui.c          **** 	else 
 301:ui.c          **** 	{
 302:ui.c          **** 		mode = ' ';
 303:ui.c          **** 		abortInput();
 304:ui.c          **** 	}		
 305:ui.c          **** }
 306:ui.c          **** 
 307:ui.c          **** // Because of the nature of the processor, strings constants use up a 
 308:ui.c          **** //   disproportionate amount of flash memory. Therefore, it makes sense to 
 309:ui.c          **** //   minimize string constant storage in memory by writing a single function
 310:ui.c          **** //   to handle frequently called string constant print calls, even if it
 311:ui.c          **** //   would be simpler (and tidier) to put it inline.
 312:ui.c          **** void printMenu(void)
 313:ui.c          **** {
  18               		.loc 1 313 0
  19               		.cfi_startproc
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 0 */
  23               	.L__stack_usage = 0
 314:ui.c          **** 	serialWrite(":-)");
  24               		.loc 1 314 0
  25 0000 80E0      		ldi r24,lo8(.LC0)
  26 0002 90E0      		ldi r25,hi8(.LC0)
  27 0004 00C0      		rjmp serialWrite
  28               	.LVL0:
  29               		.cfi_endproc
  30               	.LFE1:
  32               		.section	.rodata.str1.1
  33               	.LC1:
  34 0004 3A2D 2800 		.string	":-("
  35               		.text
  36               	.global	abortInput
  38               	abortInput:
  39               	.LFB2:
 315:ui.c          **** }
 316:ui.c          **** 
 317:ui.c          **** void abortInput(void)
 318:ui.c          **** {
  40               		.loc 1 318 0
  41               		.cfi_startproc
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
 319:ui.c          **** 	serialWrite(":-(");
  46               		.loc 1 319 0
  47 0006 80E0      		ldi r24,lo8(.LC1)
  48 0008 90E0      		ldi r25,hi8(.LC1)
  49 000a 00C0      		rjmp serialWrite
  50               	.LVL1:
  51               		.cfi_endproc
  52               	.LFE2:
  54               	.global	serialParse
  56               	serialParse:
  57               	.LFB0:
  32:ui.c          **** {
  58               		.loc 1 32 0
  59               		.cfi_startproc
  60               	/* prologue: function */
  61               	/* frame size = 0 */
  62               	/* stack size = 0 */
  63               	.L__stack_usage = 0
  58:ui.c          **** 	uint8_t				localData = serialRxData;
  64               		.loc 1 58 0
  65 000c 2091 0000 		lds r18,serialRxData
  66               	.LVL2:
  60:ui.c          **** 	serialRxData = 0;					// Clear serialRxData
  67               		.loc 1 60 0
  68 0010 1092 0000 		sts serialRxData,__zero_reg__
  75:ui.c          **** 	if (((localData == '\n') | (localData == '\r')) & (mode == ' '));
  69               		.loc 1 75 0
  70 0014 91E0      		ldi r25,lo8(1)
  71 0016 2D30      		cpi r18,lo8(13)
  72 0018 01F0      		breq .L4
  73 001a 90E0      		ldi r25,0
  74               	.L4:
  75 001c 81E0      		ldi r24,lo8(1)
  76 001e 2A30      		cpi r18,lo8(10)
  77 0020 01F0      		breq .L5
  78 0022 80E0      		ldi r24,0
  79               	.L5:
  80 0024 982B      		or r25,r24
  81 0026 8091 0000 		lds r24,mode.1505
  82 002a 31E0      		ldi r19,lo8(1)
  83 002c 8032      		cpi r24,lo8(32)
  84 002e 01F0      		breq .L6
  85 0030 30E0      		ldi r19,0
  86               	.L6:
  87 0032 9923      		tst r25
  88 0034 01F4      		brne .+2
  89 0036 00C0      		rjmp .L9
  90 0038 3111      		cpse r19,__zero_reg__
  91 003a 00C0      		rjmp .L3
  79:ui.c          **** 	else if (((localData == '\n') | (localData == '\r')) & (mode != ' '))
  92               		.loc 1 79 0
  93 003c 8032      		cpi r24,lo8(32)
  94 003e 01F4      		brne .+2
  95 0040 00C0      		rjmp .L9
  82:ui.c          **** 		switch(mode)
  96               		.loc 1 82 0
  97 0042 8536      		cpi r24,lo8(101)
  98 0044 01F0      		breq .L12
  99 0046 00F4      		brsh .L13
 100 0048 8236      		cpi r24,lo8(98)
 101 004a 01F0      		breq .L14
 102 004c 8436      		cpi r24,lo8(100)
 103 004e 01F0      		breq .L15
 104 0050 8534      		cpi r24,lo8(69)
 105 0052 01F4      		brne .L11
 126:ui.c          **** 			serialWriteInt((uint16_t)EEPROMReadByte((uint8_t)inputBufferValue));
 106               		.loc 1 126 0
 107 0054 8091 0000 		lds r24,inputBufferValue.1504
 108 0058 00D0      		rcall EEPROMReadByte
 109               	.LVL3:
 110 005a 00C0      		rjmp .L128
 111               	.LVL4:
 112               	.L13:
  82:ui.c          **** 		switch(mode)
 113               		.loc 1 82 0
 114 005c 8437      		cpi r24,lo8(116)
 115 005e 01F0      		breq .L17
 116 0060 8737      		cpi r24,lo8(119)
 117 0062 01F0      		breq .L18
 118 0064 8237      		cpi r24,lo8(114)
 119 0066 01F4      		brne .L11
 116:ui.c          **** 			serialWriteInt((uint16_t)ADXLReadByte((uint8_t)inputBufferValue));
 120               		.loc 1 116 0
 121 0068 8091 0000 		lds r24,inputBufferValue.1504
 122 006c 00D0      		rcall ADXLReadByte
 123               	.LVL5:
 124 006e 00C0      		rjmp .L128
 125               	.LVL6:
 126               	.L17:
  89:ui.c          **** 			EEPROMWriteWord((uint8_t)ATHRESH, inputBufferValue);
 127               		.loc 1 89 0
 128 0070 6091 0000 		lds r22,inputBufferValue.1504
 129 0074 7091 0000 		lds r23,inputBufferValue.1504+1
 130 0078 80E0      		ldi r24,0
 131 007a 00C0      		rjmp .L127
 132               	.L15:
  97:ui.c          **** 			t1Offset = 65535 - inputBufferValue;
 133               		.loc 1 97 0
 134 007c 8091 0000 		lds r24,inputBufferValue.1504
 135 0080 9091 0000 		lds r25,inputBufferValue.1504+1
 136 0084 8095      		com r24
 137 0086 9095      		com r25
  98:ui.c          **** 			if (t1Offset > 63535) t1Offset = 63535;
 138               		.loc 1 98 0
 139 0088 8033      		cpi r24,48
 140 008a 28EF      		ldi r18,-8
 141 008c 9207      		cpc r25,r18
 142               	.LVL7:
 143 008e 00F0      		brlo .L126
  98:ui.c          **** 			if (t1Offset > 63535) t1Offset = 63535;
 144               		.loc 1 98 0 is_stmt 0 discriminator 1
 145 0090 8FE2      		ldi r24,lo8(47)
 146 0092 98EF      		ldi r25,lo8(-8)
 147               	.L126:
 148 0094 9093 0000 		sts t1Offset+1,r25
 149 0098 8093 0000 		sts t1Offset,r24
  99:ui.c          **** 			EEPROMWriteWord((uint8_t)WAKE_OFFS, t1Offset);
 150               		.loc 1 99 0 is_stmt 1 discriminator 1
 151 009c 6091 0000 		lds r22,t1Offset
 152 00a0 7091 0000 		lds r23,t1Offset+1
 153 00a4 82E0      		ldi r24,lo8(2)
 154               	.L127:
  99:ui.c          **** 			EEPROMWriteWord((uint8_t)WAKE_OFFS, t1Offset);
 155               		.loc 1 99 0 is_stmt 0
 156 00a6 00D0      		rcall EEPROMWriteWord
 157               	.LVL8:
 100:ui.c          **** 			break;
 158               		.loc 1 100 0 is_stmt 1
 159 00a8 00C0      		rjmp .L11
 160               	.LVL9:
 161               	.L14:
 104:ui.c          **** 			serialDataBuffer = (uint8_t)inputBufferValue;
 162               		.loc 1 104 0
 163 00aa 8091 0000 		lds r24,inputBufferValue.1504
 164 00ae 8093 0000 		sts serialDataBuffer.1506,r24
 105:ui.c          **** 			break;
 165               		.loc 1 105 0
 166 00b2 00C0      		rjmp .L11
 167               	.L18:
 111:ui.c          **** 			ADXLWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
 168               		.loc 1 111 0
 169 00b4 6091 0000 		lds r22,serialDataBuffer.1506
 170 00b8 8091 0000 		lds r24,inputBufferValue.1504
 171 00bc 00D0      		rcall ADXLWriteByte
 172               	.LVL10:
 112:ui.c          **** 			break;
 173               		.loc 1 112 0
 174 00be 00C0      		rjmp .L11
 175               	.LVL11:
 176               	.L12:
 121:ui.c          **** 			EEPROMWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
 177               		.loc 1 121 0
 178 00c0 6091 0000 		lds r22,serialDataBuffer.1506
 179 00c4 8091 0000 		lds r24,inputBufferValue.1504
 180 00c8 00D0      		rcall EEPROMWriteByte
 181               	.LVL12:
 122:ui.c          **** 			break;
 182               		.loc 1 122 0
 183 00ca 00C0      		rjmp .L11
 184               	.L128:
 126:ui.c          **** 			serialWriteInt((uint16_t)EEPROMReadByte((uint8_t)inputBufferValue));
 185               		.loc 1 126 0
 186 00cc 90E0      		ldi r25,0
 187 00ce 00D0      		rcall serialWriteInt
 188               	.LVL13:
 189               	.L11:
 129:ui.c          **** 		inputBufferValue = 0;		// Clear the input buffer for next data stream.
 190               		.loc 1 129 0
 191 00d0 1092 0000 		sts inputBufferValue.1504+1,__zero_reg__
 192 00d4 1092 0000 		sts inputBufferValue.1504,__zero_reg__
 130:ui.c          **** 		mode = ' ';					// Reset the mode for next data stream.
 193               		.loc 1 130 0
 194 00d8 80E2      		ldi r24,lo8(32)
 195 00da 8093 0000 		sts mode.1505,r24
 131:ui.c          **** 		printMenu();				// Just an indicator of success.
 196               		.loc 1 131 0
 197 00de 00C0      		rjmp printMenu
 198               	.LVL14:
 199               	.L9:
 140:ui.c          **** 			(localData == 'z') |	// Force sleep in ~35ms
 200               		.loc 1 140 0
 201 00e0 91E0      		ldi r25,lo8(1)
 202 00e2 2A37      		cpi r18,lo8(122)
 203 00e4 01F0      		breq .L22
 204 00e6 90E0      		ldi r25,0
 205               	.L22:
 146:ui.c          **** 			(localData == 'p') |	// Read pin level (pins on header only)
 206               		.loc 1 146 0
 207 00e8 522F      		mov r21,r18
 208 00ea 5B7F      		andi r21,lo8(-5)
 142:ui.c          **** 			(localData == 'w') |	// Write buffered byte to ADXL362 register
 209               		.loc 1 142 0
 210 00ec 61E0      		ldi r22,lo8(1)
 211 00ee 2737      		cpi r18,lo8(119)
 212 00f0 01F0      		breq .L24
 213 00f2 60E0      		ldi r22,0
 214               	.L24:
 215 00f4 462F      		mov r20,r22
 216 00f6 492B      		or r20,r25
 145:ui.c          **** 			(localData == 'E') |	// Read byte from EEPROM address
 217               		.loc 1 145 0
 218 00f8 61E0      		ldi r22,lo8(1)
 219 00fa 2534      		cpi r18,lo8(69)
 220 00fc 01F0      		breq .L25
 221 00fe 60E0      		ldi r22,0
 222               	.L25:
 143:ui.c          **** 			(localData == 'r') |	// Read ADXL362 register
 223               		.loc 1 143 0
 224 0100 642B      		or r22,r20
 138:ui.c          **** 			(localData == 't') |	// Change the threshold setting
 225               		.loc 1 138 0
 226 0102 41E0      		ldi r20,lo8(1)
 227 0104 7CE9      		ldi r23,lo8(-100)
 228 0106 720F      		add r23,r18
 229 0108 7230      		cpi r23,lo8(2)
 230 010a 00F0      		brlo .L26
 231 010c 40E0      		ldi r20,0
 232               	.L26:
 144:ui.c          **** 			(localData == 'e') |	// Write buffered byte to EEPROM address
 233               		.loc 1 144 0
 234 010e 462B      		or r20,r22
 147:ui.c          **** 			(localData == 'H') |	// Set pin high (pins on header only)
 235               		.loc 1 147 0
 236 0110 71E0      		ldi r23,lo8(1)
 237 0112 5834      		cpi r21,lo8(72)
 238 0114 01F0      		breq .L27
 239 0116 70E0      		ldi r23,0
 240               	.L27:
 145:ui.c          **** 			(localData == 'E') |	// Read byte from EEPROM address
 241               		.loc 1 145 0
 242 0118 742B      		or r23,r20
 141:ui.c          **** 			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
 243               		.loc 1 141 0
 244 011a 61E0      		ldi r22,lo8(1)
 245 011c 422F      		mov r20,r18
 246 011e 4F7E      		andi r20,lo8(-17)
 247 0120 4236      		cpi r20,lo8(98)
 248 0122 01F0      		breq .L28
 249 0124 60E0      		ldi r22,0
 250               	.L28:
 146:ui.c          **** 			(localData == 'p') |	// Read pin level (pins on header only)
 251               		.loc 1 146 0
 252 0126 672B      		or r22,r23
 253 0128 41E0      		ldi r20,lo8(1)
 254 012a 5037      		cpi r21,lo8(112)
 255 012c 01F0      		breq .L29
 256 012e 40E0      		ldi r20,0
 257               	.L29:
 147:ui.c          **** 			(localData == 'H') |	// Set pin high (pins on header only)
 258               		.loc 1 147 0
 259 0130 462B      		or r20,r22
 137:ui.c          **** 	else if ((mode == ' ')&(
 260               		.loc 1 137 0
 261 0132 01F0      		breq .L23
 262 0134 3323      		tst r19
 263 0136 01F0      		breq .L23
 151:ui.c          **** 		mode = localData;
 264               		.loc 1 151 0
 265 0138 2093 0000 		sts mode.1505,r18
 157:ui.c          **** 	    if (mode == 'z')
 266               		.loc 1 157 0
 267 013c 9923      		tst r25
 268 013e 01F4      		brne .+2
 269 0140 00C0      		rjmp .L3
 159:ui.c          **** 			TCNT1 = 65500;	// Set TCNT1 to *almost* overflowing. Sleep will
 270               		.loc 1 159 0
 271 0142 8CED      		ldi r24,lo8(-36)
 272 0144 9FEF      		ldi r25,lo8(-1)
 273 0146 9DBD      		out 0x2c+1,r25
 274 0148 8CBD      		out 0x2c,r24
 161:ui.c          **** 			mode = ' ';		// Clear mode for later.
 275               		.loc 1 161 0
 276 014a 80E2      		ldi r24,lo8(32)
 277 014c 8093 0000 		sts mode.1505,r24
 278 0150 0895      		ret
 279               	.L23:
 173:ui.c          **** 				(mode == 'p')|\
 280               		.loc 1 173 0
 281 0152 982F      		mov r25,r24
 282 0154 9B7F      		andi r25,lo8(-5)
 172:ui.c          **** 				(mode == 'E')|\
 283               		.loc 1 172 0
 284 0156 51E0      		ldi r21,lo8(1)
 285 0158 8534      		cpi r24,lo8(69)
 286 015a 01F0      		breq .L33
 287 015c 50E0      		ldi r21,0
 288               	.L33:
 169:ui.c          **** 				(mode == 'w')|\
 289               		.loc 1 169 0
 290 015e 31E0      		ldi r19,lo8(1)
 291 0160 8737      		cpi r24,lo8(119)
 292 0162 01F0      		breq .L34
 293 0164 30E0      		ldi r19,0
 294               	.L34:
 171:ui.c          **** 				(mode == 'e')|\
 295               		.loc 1 171 0
 296 0166 352B      		or r19,r21
 167:ui.c          **** 	else if (	(mode == 't')|\
 297               		.loc 1 167 0
 298 0168 51E0      		ldi r21,lo8(1)
 299 016a 4CE9      		ldi r20,lo8(-100)
 300 016c 480F      		add r20,r24
 301 016e 4230      		cpi r20,lo8(2)
 302 0170 00F0      		brlo .L35
 303 0172 50E0      		ldi r21,0
 304               	.L35:
 172:ui.c          **** 				(mode == 'E')|\
 305               		.loc 1 172 0
 306 0174 532B      		or r21,r19
 174:ui.c          **** 				(mode == 'H')|\
 307               		.loc 1 174 0
 308 0176 41E0      		ldi r20,lo8(1)
 309 0178 9834      		cpi r25,lo8(72)
 310 017a 01F0      		breq .L36
 311 017c 40E0      		ldi r20,0
 312               	.L36:
 173:ui.c          **** 				(mode == 'p')|\
 313               		.loc 1 173 0
 314 017e 452B      		or r20,r21
 176:ui.c          **** 				(mode == 'b'))
 315               		.loc 1 176 0
 316 0180 31E0      		ldi r19,lo8(1)
 317 0182 582F      		mov r21,r24
 318 0184 5F7E      		andi r21,lo8(-17)
 319 0186 5236      		cpi r21,lo8(98)
 320 0188 01F0      		breq .L37
 321 018a 30E0      		ldi r19,0
 322               	.L37:
 174:ui.c          **** 				(mode == 'H')|\
 323               		.loc 1 174 0
 324 018c 342B      		or r19,r20
 167:ui.c          **** 	else if (	(mode == 't')|\
 325               		.loc 1 167 0
 326 018e 01F4      		brne .L63
 173:ui.c          **** 				(mode == 'p')|\
 327               		.loc 1 173 0
 328 0190 9037      		cpi r25,lo8(112)
 329 0192 01F0      		breq .+2
 330 0194 00C0      		rjmp .L31
 331               	.L63:
 184:ui.c          **** 		if (mode == 'p')
 332               		.loc 1 184 0
 333 0196 8037      		cpi r24,lo8(112)
 334 0198 01F4      		brne .L39
 186:ui.c          **** 			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 335               		.loc 1 186 0
 336 019a 80E2      		ldi r24,lo8(32)
 337 019c 8093 0000 		sts mode.1505,r24
 187:ui.c          **** 			switch(localData)
 338               		.loc 1 187 0
 339 01a0 2233      		cpi r18,lo8(50)
 340 01a2 01F0      		breq .L41
 341 01a4 00F4      		brsh .L42
 342 01a6 2033      		cpi r18,lo8(48)
 343 01a8 01F0      		breq .L43
 344 01aa 2133      		cpi r18,lo8(49)
 345 01ac 01F0      		breq .+2
 346 01ae 00C0      		rjmp .L130
 195:ui.c          **** 				DDRB &= ~(1<<PB1);
 347               		.loc 1 195 0
 348 01b0 B998      		cbi 0x17,1
 196:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB1))>>PB1));
 349               		.loc 1 196 0
 350 01b2 86B3      		in r24,0x16
 351 01b4 8695      		lsr r24
 352 01b6 8170      		andi r24,1
 353 01b8 00C0      		rjmp .L129
 354               	.L42:
 187:ui.c          **** 			switch(localData)
 355               		.loc 1 187 0
 356 01ba 2333      		cpi r18,lo8(51)
 357 01bc 01F0      		breq .L45
 358 01be 2633      		cpi r18,lo8(54)
 359 01c0 01F0      		breq .+2
 360 01c2 00C0      		rjmp .L130
 207:ui.c          **** 				DDRD &= ~(1<<PD6);
 361               		.loc 1 207 0
 362 01c4 8E98      		cbi 0x11,6
 208:ui.c          **** 				serialWriteChar('0'+((PIND & (1<<PD6))>>PD6));
 363               		.loc 1 208 0
 364 01c6 80B3      		in r24,0x10
 365 01c8 86FB      		bst r24,6
 366 01ca 8827      		clr r24
 367 01cc 80F9      		bld r24,0
 368 01ce 00C0      		rjmp .L129
 369               	.L43:
 190:ui.c          **** 				DDRB &= ~(1<<PB0);							// make pin input
 370               		.loc 1 190 0
 371 01d0 B898      		cbi 0x17,0
 191:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB0))>>PB0));    // isolate bit and
 372               		.loc 1 191 0
 373 01d2 86B3      		in r24,0x16
 374 01d4 8170      		andi r24,lo8(1)
 375 01d6 00C0      		rjmp .L129
 376               	.L41:
 199:ui.c          **** 				DDRB &= ~(1<<PB2);
 377               		.loc 1 199 0
 378 01d8 BA98      		cbi 0x17,2
 200:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB2))>>PB2));
 379               		.loc 1 200 0
 380 01da 86B3      		in r24,0x16
 381 01dc 82FB      		bst r24,2
 382 01de 8827      		clr r24
 383 01e0 80F9      		bld r24,0
 384               	.L129:
 196:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB1))>>PB1));
 385               		.loc 1 196 0
 386 01e2 805D      		subi r24,lo8(-(48))
 387 01e4 00C0      		rjmp serialWriteChar
 388               	.LVL15:
 389               	.L45:
 203:ui.c          **** 				DDRB &= ~(1<<PB3);
 390               		.loc 1 203 0
 391 01e6 BB98      		cbi 0x17,3
 204:ui.c          **** 				serialWriteChar('0'+((PINB & (1<<PB3))>>PB3));
 392               		.loc 1 204 0
 393 01e8 86B3      		in r24,0x16
 394 01ea 83FB      		bst r24,3
 395 01ec 8827      		clr r24
 396 01ee 80F9      		bld r24,0
 397 01f0 00C0      		rjmp .L129
 398               	.L39:
 219:ui.c          **** 		else if (mode == 'H')
 399               		.loc 1 219 0
 400 01f2 8834      		cpi r24,lo8(72)
 401 01f4 01F4      		brne .L47
 221:ui.c          **** 			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 402               		.loc 1 221 0
 403 01f6 80E2      		ldi r24,lo8(32)
 404 01f8 8093 0000 		sts mode.1505,r24
 222:ui.c          **** 			switch(localData)
 405               		.loc 1 222 0
 406 01fc 2233      		cpi r18,lo8(50)
 407 01fe 01F0      		breq .L49
 408 0200 00F4      		brsh .L50
 409 0202 2033      		cpi r18,lo8(48)
 410 0204 01F0      		breq .L51
 411 0206 2133      		cpi r18,lo8(49)
 412 0208 01F0      		breq .+2
 413 020a 00C0      		rjmp .L130
 229:ui.c          **** 				DDRB |= (1<<PB1);
 414               		.loc 1 229 0
 415 020c B99A      		sbi 0x17,1
 230:ui.c          **** 				PORTB |= (1<<PB1);
 416               		.loc 1 230 0
 417 020e C19A      		sbi 0x18,1
 231:ui.c          **** 				break;
 418               		.loc 1 231 0
 419 0210 0895      		ret
 420               	.L50:
 222:ui.c          **** 			switch(localData)
 421               		.loc 1 222 0
 422 0212 2333      		cpi r18,lo8(51)
 423 0214 01F0      		breq .L53
 424 0216 2633      		cpi r18,lo8(54)
 425 0218 01F0      		breq .+2
 426 021a 00C0      		rjmp .L130
 241:ui.c          **** 				DDRD |= (1<<PD6);
 427               		.loc 1 241 0
 428 021c 8E9A      		sbi 0x11,6
 242:ui.c          **** 				PORTD |= (1<<PD6);
 429               		.loc 1 242 0
 430 021e 969A      		sbi 0x12,6
 243:ui.c          **** 				break;
 431               		.loc 1 243 0
 432 0220 0895      		ret
 433               	.L51:
 225:ui.c          **** 				DDRB |= (1<<PB0);	// make pin an output
 434               		.loc 1 225 0
 435 0222 B89A      		sbi 0x17,0
 226:ui.c          **** 				PORTB |= (1<<PB0);  // set pin high
 436               		.loc 1 226 0
 437 0224 C09A      		sbi 0x18,0
 227:ui.c          **** 				break;
 438               		.loc 1 227 0
 439 0226 0895      		ret
 440               	.L49:
 233:ui.c          **** 				DDRB |= (1<<PB2);
 441               		.loc 1 233 0
 442 0228 BA9A      		sbi 0x17,2
 234:ui.c          **** 				PORTB |= (1<<PB2);
 443               		.loc 1 234 0
 444 022a C29A      		sbi 0x18,2
 235:ui.c          **** 				break;
 445               		.loc 1 235 0
 446 022c 0895      		ret
 447               	.L53:
 237:ui.c          **** 				DDRB |= (1<<PB3);
 448               		.loc 1 237 0
 449 022e BB9A      		sbi 0x17,3
 238:ui.c          **** 				PORTB |= (1<<PB3);
 450               		.loc 1 238 0
 451 0230 C39A      		sbi 0x18,3
 239:ui.c          **** 				break;
 452               		.loc 1 239 0
 453 0232 0895      		ret
 454               	.L47:
 253:ui.c          **** 		else if (mode == 'L')
 455               		.loc 1 253 0
 456 0234 8C34      		cpi r24,lo8(76)
 457 0236 01F4      		brne .L55
 255:ui.c          **** 			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 458               		.loc 1 255 0
 459 0238 80E2      		ldi r24,lo8(32)
 460 023a 8093 0000 		sts mode.1505,r24
 256:ui.c          **** 			switch(localData)
 461               		.loc 1 256 0
 462 023e 2233      		cpi r18,lo8(50)
 463 0240 01F0      		breq .L57
 464 0242 00F4      		brsh .L58
 465 0244 2033      		cpi r18,lo8(48)
 466 0246 01F0      		breq .L59
 467 0248 2133      		cpi r18,lo8(49)
 468 024a 01F4      		brne .L130
 263:ui.c          **** 				DDRB |= (1<<PB1);
 469               		.loc 1 263 0
 470 024c B99A      		sbi 0x17,1
 264:ui.c          **** 				PORTB &= ~(1<<PB1);
 471               		.loc 1 264 0
 472 024e C198      		cbi 0x18,1
 265:ui.c          **** 				break;
 473               		.loc 1 265 0
 474 0250 0895      		ret
 475               	.L58:
 256:ui.c          **** 			switch(localData)
 476               		.loc 1 256 0
 477 0252 2333      		cpi r18,lo8(51)
 478 0254 01F0      		breq .L61
 479 0256 2633      		cpi r18,lo8(54)
 480 0258 01F4      		brne .L130
 275:ui.c          **** 				DDRD |= (1<<PD6);
 481               		.loc 1 275 0
 482 025a 8E9A      		sbi 0x11,6
 276:ui.c          **** 				PORTD &= ~(1<<PD6);
 483               		.loc 1 276 0
 484 025c 9698      		cbi 0x12,6
 277:ui.c          **** 				break;
 485               		.loc 1 277 0
 486 025e 0895      		ret
 487               	.L59:
 259:ui.c          **** 				DDRB |= (1<<PB0);	// make pin an output
 488               		.loc 1 259 0
 489 0260 B89A      		sbi 0x17,0
 260:ui.c          **** 				PORTB &= ~(1<<PB0); // set pin low
 490               		.loc 1 260 0
 491 0262 C098      		cbi 0x18,0
 261:ui.c          **** 				break;
 492               		.loc 1 261 0
 493 0264 0895      		ret
 494               	.L57:
 267:ui.c          **** 				DDRB |= (1<<PB2);
 495               		.loc 1 267 0
 496 0266 BA9A      		sbi 0x17,2
 268:ui.c          **** 				PORTB &= ~(1<<PB2);
 497               		.loc 1 268 0
 498 0268 C298      		cbi 0x18,2
 269:ui.c          **** 				break;
 499               		.loc 1 269 0
 500 026a 0895      		ret
 501               	.L61:
 271:ui.c          **** 				DDRB |= (1<<PB3);
 502               		.loc 1 271 0
 503 026c BB9A      		sbi 0x17,3
 272:ui.c          **** 				PORTB &= ~(1<<PB3);
 504               		.loc 1 272 0
 505 026e C398      		cbi 0x18,3
 273:ui.c          **** 				break;
 506               		.loc 1 273 0
 507 0270 0895      		ret
 508               	.L55:
 285:ui.c          **** 		else if (('0' <= localData) & (localData <= '9'))
 509               		.loc 1 285 0
 510 0272 80ED      		ldi r24,lo8(-48)
 511 0274 820F      		add r24,r18
 512 0276 8A30      		cpi r24,lo8(10)
 513 0278 00F4      		brsh .L31
 287:ui.c          **** 			inputBufferValue *= 10;
 514               		.loc 1 287 0
 515 027a 8091 0000 		lds r24,inputBufferValue.1504
 516 027e 9091 0000 		lds r25,inputBufferValue.1504+1
 517 0282 6AE0      		ldi r22,lo8(10)
 518 0284 70E0      		ldi r23,0
 519 0286 00D0      		rcall __mulhi3
 288:ui.c          **** 			inputBufferValue += (localData - '0');
 520               		.loc 1 288 0
 521 0288 820F      		add r24,r18
 522 028a 911D      		adc r25,__zero_reg__
 523 028c C097      		sbiw r24,48
 524 028e 9093 0000 		sts inputBufferValue.1504+1,r25
 525 0292 8093 0000 		sts inputBufferValue.1504,r24
 526 0296 0895      		ret
 527               	.L31:
 294:ui.c          **** 			mode = ' ';
 528               		.loc 1 294 0
 529 0298 80E2      		ldi r24,lo8(32)
 530 029a 8093 0000 		sts mode.1505,r24
 531               	.L130:
 295:ui.c          **** 			abortInput();
 532               		.loc 1 295 0
 533 029e 00C0      		rjmp abortInput
 534               	.LVL16:
 535               	.L3:
 536 02a0 0895      		ret
 537               		.cfi_endproc
 538               	.LFE0:
 540               		.local	serialDataBuffer.1506
 541               		.comm	serialDataBuffer.1506,1,1
 542               		.local	inputBufferValue.1504
 543               		.comm	inputBufferValue.1504,2,1
 544               		.data
 547               	mode.1505:
 548 0000 20        		.byte	32
 549               		.text
 550               	.Letext0:
 551               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
 552               		.file 3 "eeprom.h"
 553               		.file 4 "ADXL362.h"
 554               		.file 5 "serial.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ui.c
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:2      *ABS*:0000003d __SP_L__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:3      *ABS*:0000003f __SREG__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:4      *ABS*:00000000 __tmp_reg__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:5      *ABS*:00000001 __zero_reg__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:15     .text:00000000 printMenu
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:38     .text:00000006 abortInput
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:56     .text:0000000c serialParse
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:547    .data:00000000 mode.1505
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//ccAnHkwg.s:541    .bss:00000001 inputBufferValue.1504
                             .bss:00000000 serialDataBuffer.1506

UNDEFINED SYMBOLS
serialWrite
serialRxData
EEPROMReadByte
ADXLReadByte
t1Offset
EEPROMWriteWord
ADXLWriteByte
EEPROMWriteByte
serialWriteInt
serialWriteChar
__mulhi3
__do_copy_data
__do_clear_bss
