
wake-on-shake.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006c4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  000006c4  00000758  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000007  0080006c  0080006c  00000764  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00000764  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000188  00000000  00000000  00000778  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000113e  00000000  00000000  00000900  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000689  00000000  00000000  00001a3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000701  00000000  00000000  000020c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002c0  00000000  00000000  000027c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002db  00000000  00000000  00002a88  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000667  00000000  00000000  00002d63  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  000033ca  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	14 c0       	rjmp	.+40     	; 0x2a <__ctors_end>
   2:	1f c2       	rjmp	.+1086   	; 0x442 <__vector_1>
   4:	35 c2       	rjmp	.+1130   	; 0x470 <__vector_2>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	0c c2       	rjmp	.+1048   	; 0x424 <__vector_5>
   c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	22 c0       	rjmp	.+68     	; 0x5c <__bad_interrupt>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>
  26:	1a c0       	rjmp	.+52     	; 0x5c <__bad_interrupt>
  28:	19 c0       	rjmp	.+50     	; 0x5c <__bad_interrupt>

0000002a <__ctors_end>:
  2a:	11 24       	eor	r1, r1
  2c:	1f be       	out	0x3f, r1	; 63
  2e:	cf ed       	ldi	r28, 0xDF	; 223
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e4 ec       	ldi	r30, 0xC4	; 196
  3a:	f6 e0       	ldi	r31, 0x06	; 6
  3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0
  42:	ac 36       	cpi	r26, 0x6C	; 108
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <__SP_L__+0x1>

00000048 <__do_clear_bss>:
  48:	20 e0       	ldi	r18, 0x00	; 0
  4a:	ac e6       	ldi	r26, 0x6C	; 108
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	a3 37       	cpi	r26, 0x73	; 115
  54:	b2 07       	cpc	r27, r18
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	c1 d2       	rcall	.+1410   	; 0x5dc <main>
  5a:	32 c3       	rjmp	.+1636   	; 0x6c0 <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <EEPROMRetrieve>:
}

// Utility function which pulls the various operational paramters out of EEPROM,
//   puts them into SRAM, and prints them over the serial line.
void EEPROMRetrieve(void)
{
  5e:	cf 93       	push	r28
  60:	df 93       	push	r29
	uint16_t threshold = EEPROMReadWord((uint8_t)ATHRESH);		// Activity threshold. See
  62:	80 e0       	ldi	r24, 0x00	; 0
  64:	9e d2       	rcall	.+1340   	; 0x5a2 <EEPROMReadWord>
  66:	ec 01       	movw	r28, r24
														//   ADXL362 datasheet for info.
	t1Offset =  EEPROMReadWord((uint8_t)WAKE_OFFS);     // (65535 - t1Offset)ms elapse
  68:	82 e0       	ldi	r24, 0x02	; 2
  6a:	9b d2       	rcall	.+1334   	; 0x5a2 <EEPROMReadWord>
  6c:	90 93 72 00 	sts	0x0072, r25
  70:	80 93 71 00 	sts	0x0071, r24
														//   between Timer1 interrupts.
	serialWriteInt(threshold);							// Print threshold in human format.
  74:	ce 01       	movw	r24, r28
  76:	89 d1       	rcall	.+786    	; 0x38a <serialWriteInt>
	serialWriteInt(65535 - t1Offset);					// Print the delay before sleep
  78:	80 91 71 00 	lds	r24, 0x0071
  7c:	90 91 72 00 	lds	r25, 0x0072
  80:	80 95       	com	r24
  82:	90 95       	com	r25
														//   in human format.
}
  84:	df 91       	pop	r29
  86:	cf 91       	pop	r28
	uint16_t threshold = EEPROMReadWord((uint8_t)ATHRESH);		// Activity threshold. See
														//   ADXL362 datasheet for info.
	t1Offset =  EEPROMReadWord((uint8_t)WAKE_OFFS);     // (65535 - t1Offset)ms elapse
														//   between Timer1 interrupts.
	serialWriteInt(threshold);							// Print threshold in human format.
	serialWriteInt(65535 - t1Offset);					// Print the delay before sleep
  88:	80 c1       	rjmp	.+768    	; 0x38a <serialWriteInt>

0000008a <EEPROMConfig>:
//   change these to more manageable values the first time the board powers up, or the
//   sleep interrupt will happen WAY too fast and the motion threshold will be WAY too
//   high for practicality.
void EEPROMConfig(void)
{
	t1Offset  = 60535;		// Corresponds to ~5s delay before going to sleep
  8a:	87 e7       	ldi	r24, 0x77	; 119
  8c:	9c ee       	ldi	r25, 0xEC	; 236
  8e:	90 93 72 00 	sts	0x0072, r25
  92:	80 93 71 00 	sts	0x0071, r24
	// Now let's store these, along with the "key" that let's us know we've done this.
	EEPROMWriteWord((uint8_t)ATHRESH, (uint16_t) 150);
  96:	66 e9       	ldi	r22, 0x96	; 150
  98:	70 e0       	ldi	r23, 0x00	; 0
  9a:	80 e0       	ldi	r24, 0x00	; 0
  9c:	6c d2       	rcall	.+1240   	; 0x576 <EEPROMWriteWord>
	EEPROMWriteWord((uint8_t)WAKE_OFFS, (uint16_t)t1Offset);
  9e:	60 91 71 00 	lds	r22, 0x0071
  a2:	70 91 72 00 	lds	r23, 0x0072
  a6:	82 e0       	ldi	r24, 0x02	; 2
  a8:	66 d2       	rcall	.+1228   	; 0x576 <EEPROMWriteWord>
	EEPROMWriteWord((uint8_t)ITHRESH, (uint16_t)50);
  aa:	62 e3       	ldi	r22, 0x32	; 50
  ac:	70 e0       	ldi	r23, 0x00	; 0
  ae:	84 e0       	ldi	r24, 0x04	; 4
  b0:	62 d2       	rcall	.+1220   	; 0x576 <EEPROMWriteWord>
	EEPROMWriteWord((uint8_t)ITIME, (uint16_t)15);
  b2:	6f e0       	ldi	r22, 0x0F	; 15
  b4:	70 e0       	ldi	r23, 0x00	; 0
  b6:	86 e0       	ldi	r24, 0x06	; 6
  b8:	5e d2       	rcall	.+1212   	; 0x576 <EEPROMWriteWord>
	EEPROMWriteByte((uint8_t)KEY_ADDR, (uint8_t)KEY);
  ba:	6b e7       	ldi	r22, 0x7B	; 123
  bc:	8f e7       	ldi	r24, 0x7F	; 127
  be:	51 c2       	rjmp	.+1186   	; 0x562 <EEPROMWriteByte>

000000c0 <printMenu>:
//   minimize string constant storage in memory by writing a single function
//   to handle frequently called string constant print calls, even if it
//   would be simpler (and tidier) to put it inline.
void printMenu(void)
{
	serialWrite(":-)");
  c0:	83 e6       	ldi	r24, 0x63	; 99
  c2:	90 e0       	ldi	r25, 0x00	; 0
  c4:	57 c1       	rjmp	.+686    	; 0x374 <serialWrite>

000000c6 <abortInput>:
}

void abortInput(void)
{
	serialWrite(":-(");
  c6:	87 e6       	ldi	r24, 0x67	; 103
  c8:	90 e0       	ldi	r25, 0x00	; 0
  ca:	54 c1       	rjmp	.+680    	; 0x374 <serialWrite>

000000cc <serialParse>:
	//   quite some time, as do EEPROM writes), we want to know that nothing
	//   has changed between when we enter the function and code we encounter
	//   further down. The only way to ensure that is to buffer serialRxData
	//   locally, since serialRxData can be changed by the serial receive ISR
	//   at any time.
	uint8_t				localData = serialRxData;
  cc:	20 91 6c 00 	lds	r18, 0x006C
	
	serialRxData = 0;					// Clear serialRxData
  d0:	10 92 6c 00 	sts	0x006C, r1
//   send at the end of the line, so we need to respond to either if they
//   happen at the end of data entry, and ignore them any other time, since
//   some programs may send BOTH CR and LF. We also don't want to let this be
//   the default case, because it would be annoying to see "Invalid input"
//   every time we enter a value.
	if (((localData == '\n') | (localData == '\r')) & (mode == ' '));
  d4:	91 e0       	ldi	r25, 0x01	; 1
  d6:	2d 30       	cpi	r18, 0x0D	; 13
  d8:	09 f0       	breq	.+2      	; 0xdc <serialParse+0x10>
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	2a 30       	cpi	r18, 0x0A	; 10
  e0:	09 f0       	breq	.+2      	; 0xe4 <__stack+0x5>
  e2:	80 e0       	ldi	r24, 0x00	; 0
  e4:	98 2b       	or	r25, r24
  e6:	80 91 60 00 	lds	r24, 0x0060
  ea:	31 e0       	ldi	r19, 0x01	; 1
  ec:	80 32       	cpi	r24, 0x20	; 32
  ee:	09 f0       	breq	.+2      	; 0xf2 <__stack+0x13>
  f0:	30 e0       	ldi	r19, 0x00	; 0
  f2:	99 23       	and	r25, r25
  f4:	09 f4       	brne	.+2      	; 0xf8 <__stack+0x19>
  f6:	54 c0       	rjmp	.+168    	; 0x1a0 <__stack+0xc1>
  f8:	31 11       	cpse	r19, r1
  fa:	32 c1       	rjmp	.+612    	; 0x360 <__stack+0x281>
	
// CR/LF when we're in data reading mode: respond to whichever one happens first
//   by parsing the received data.
	else if (((localData == '\n') | (localData == '\r')) & (mode != ' '))
  fc:	80 32       	cpi	r24, 0x20	; 32
  fe:	09 f4       	brne	.+2      	; 0x102 <__stack+0x23>
 100:	4f c0       	rjmp	.+158    	; 0x1a0 <__stack+0xc1>
	{
		// Now, make a decision about what to do with the data depending on the mode.
		switch(mode)
 102:	85 36       	cpi	r24, 0x65	; 101
 104:	e9 f1       	breq	.+122    	; 0x180 <__stack+0xa1>
 106:	50 f4       	brcc	.+20     	; 0x11c <__stack+0x3d>
 108:	82 36       	cpi	r24, 0x62	; 98
 10a:	79 f1       	breq	.+94     	; 0x16a <__stack+0x8b>
 10c:	84 36       	cpi	r24, 0x64	; 100
 10e:	b1 f0       	breq	.+44     	; 0x13c <__stack+0x5d>
 110:	85 34       	cpi	r24, 0x45	; 69
 112:	f1 f5       	brne	.+124    	; 0x190 <__stack+0xb1>
			EEPROMWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
			break;
			// 'E' directs the device to return a value stored in the EEPROM
			//   over the serial port from the address specified.
			case 'E':
			serialWriteInt((uint16_t)EEPROMReadByte((uint8_t)inputBufferValue));
 114:	80 91 6f 00 	lds	r24, 0x006F
 118:	3a d2       	rcall	.+1140   	; 0x58e <EEPROMReadByte>
 11a:	38 c0       	rjmp	.+112    	; 0x18c <__stack+0xad>
// CR/LF when we're in data reading mode: respond to whichever one happens first
//   by parsing the received data.
	else if (((localData == '\n') | (localData == '\r')) & (mode != ' '))
	{
		// Now, make a decision about what to do with the data depending on the mode.
		switch(mode)
 11c:	84 37       	cpi	r24, 0x74	; 116
 11e:	41 f0       	breq	.+16     	; 0x130 <__stack+0x51>
 120:	87 37       	cpi	r24, 0x77	; 119
 122:	41 f1       	breq	.+80     	; 0x174 <__stack+0x95>
 124:	82 37       	cpi	r24, 0x72	; 114
 126:	a1 f5       	brne	.+104    	; 0x190 <__stack+0xb1>
			ADXLWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
			break;
			// 'r' indicates a desire to read from an address in the ADXL part.
			//   inputBufferValue provides an address to read from.
			case 'r':
			serialWriteInt((uint16_t)ADXLReadByte((uint8_t)inputBufferValue));
 128:	80 91 6f 00 	lds	r24, 0x006F
 12c:	cf d1       	rcall	.+926    	; 0x4cc <ADXLReadByte>
 12e:	2e c0       	rjmp	.+92     	; 0x18c <__stack+0xad>
			// 't' indicates that user wanted to change the threshold setting, so
			//   let's store the inputBufferValue in EEPROM and update the value in
			//   memory. We won't bother updating the ADXL362 just yet; that will
			//   happen right before we go to sleep.
			case 't':
			EEPROMWriteWord((uint8_t)ATHRESH, inputBufferValue);
 130:	60 91 6f 00 	lds	r22, 0x006F
 134:	70 91 70 00 	lds	r23, 0x0070
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	15 c0       	rjmp	.+42     	; 0x166 <__stack+0x87>
			//   so we need to convert the user's value in milliseconds to an offset
			//   value that can be loaded into TCNT1. We'll also include a check so
			//   the user can't accidentally set the timeout period so short as to
			//   render the device difficult to program.
			case 'd':
			t1Offset = 65535 - inputBufferValue;
 13c:	80 91 6f 00 	lds	r24, 0x006F
 140:	90 91 70 00 	lds	r25, 0x0070
 144:	80 95       	com	r24
 146:	90 95       	com	r25
			if (t1Offset > 63535) t1Offset = 63535;
 148:	80 33       	cpi	r24, 0x30	; 48
 14a:	28 ef       	ldi	r18, 0xF8	; 248
 14c:	92 07       	cpc	r25, r18
 14e:	10 f0       	brcs	.+4      	; 0x154 <__stack+0x75>
 150:	8f e2       	ldi	r24, 0x2F	; 47
 152:	98 ef       	ldi	r25, 0xF8	; 248
 154:	90 93 72 00 	sts	0x0072, r25
 158:	80 93 71 00 	sts	0x0071, r24
			EEPROMWriteWord((uint8_t)WAKE_OFFS, t1Offset);
 15c:	60 91 71 00 	lds	r22, 0x0071
 160:	70 91 72 00 	lds	r23, 0x0072
 164:	82 e0       	ldi	r24, 0x02	; 2
 166:	07 d2       	rcall	.+1038   	; 0x576 <EEPROMWriteWord>
			break;
 168:	13 c0       	rjmp	.+38     	; 0x190 <__stack+0xb1>
			// 'b' indicates that the user wishes to buffer a value to be written
			//   to something, either the ADXL362 -or- an EEPROM location in the tiny.
			case 'b':
			serialDataBuffer = (uint8_t)inputBufferValue;
 16a:	80 91 6f 00 	lds	r24, 0x006F
 16e:	80 93 6e 00 	sts	0x006E, r24
			break;
 172:	0e c0       	rjmp	.+28     	; 0x190 <__stack+0xb1>
			// 'w' indicates that the user wants to write a value directly to the
			//   ADXL362 part. In this case, inputBufferValue is taken as an
			//   address to write to, and the data to be written is in the
			//   serialDataBuffer variable.
			case 'w':
			ADXLWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
 174:	60 91 6e 00 	lds	r22, 0x006E
 178:	80 91 6f 00 	lds	r24, 0x006F
 17c:	b4 d1       	rcall	.+872    	; 0x4e6 <ADXLWriteByte>
			break;
 17e:	08 c0       	rjmp	.+16     	; 0x190 <__stack+0xb1>
			serialWriteInt((uint16_t)ADXLReadByte((uint8_t)inputBufferValue));
			break;
			// 'e' directs the device to store the buffered value into the
			//   address provided by inputBufferValue.
			case 'e':
			EEPROMWriteByte((uint8_t)inputBufferValue, serialDataBuffer);
 180:	60 91 6e 00 	lds	r22, 0x006E
 184:	80 91 6f 00 	lds	r24, 0x006F
 188:	ec d1       	rcall	.+984    	; 0x562 <EEPROMWriteByte>
			break;
 18a:	02 c0       	rjmp	.+4      	; 0x190 <__stack+0xb1>
			// 'E' directs the device to return a value stored in the EEPROM
			//   over the serial port from the address specified.
			case 'E':
			serialWriteInt((uint16_t)EEPROMReadByte((uint8_t)inputBufferValue));
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	fd d0       	rcall	.+506    	; 0x38a <serialWriteInt>
			break;
		}
		inputBufferValue = 0;		// Clear the input buffer for next data stream.
 190:	10 92 70 00 	sts	0x0070, r1
 194:	10 92 6f 00 	sts	0x006F, r1
		mode = ' ';					// Reset the mode for next data stream.
 198:	80 e2       	ldi	r24, 0x20	; 32
 19a:	80 93 60 00 	sts	0x0060, r24
		printMenu();				// Just an indicator of success.
 19e:	90 cf       	rjmp	.-224    	; 0xc0 <printMenu>
//   let's activate that mode. In some cases, we want immediate action, and
//   then to return to null mode.
	else if ((mode == ' ')&(
			(localData == 't') |	// Change the threshold setting
			(localData == 'd') |	// Change the delay before sleep
			(localData == 'z') |	// Force sleep in ~35ms
 1a0:	91 e0       	ldi	r25, 0x01	; 1
 1a2:	2a 37       	cpi	r18, 0x7A	; 122
 1a4:	09 f0       	breq	.+2      	; 0x1a8 <__stack+0xc9>
 1a6:	90 e0       	ldi	r25, 0x00	; 0
			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
			(localData == 'w') |	// Write buffered byte to ADXL362 register
			(localData == 'r') |	// Read ADXL362 register
			(localData == 'e') |	// Write buffered byte to EEPROM address
			(localData == 'E') |	// Read byte from EEPROM address
			(localData == 'p') |	// Read pin level (pins on header only)
 1a8:	52 2f       	mov	r21, r18
 1aa:	5b 7f       	andi	r21, 0xFB	; 251
	else if ((mode == ' ')&(
			(localData == 't') |	// Change the threshold setting
			(localData == 'd') |	// Change the delay before sleep
			(localData == 'z') |	// Force sleep in ~35ms
			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
			(localData == 'w') |	// Write buffered byte to ADXL362 register
 1ac:	61 e0       	ldi	r22, 0x01	; 1
 1ae:	27 37       	cpi	r18, 0x77	; 119
 1b0:	09 f0       	breq	.+2      	; 0x1b4 <__stack+0xd5>
 1b2:	60 e0       	ldi	r22, 0x00	; 0
 1b4:	46 2f       	mov	r20, r22
 1b6:	49 2b       	or	r20, r25
			(localData == 'r') |	// Read ADXL362 register
			(localData == 'e') |	// Write buffered byte to EEPROM address
			(localData == 'E') |	// Read byte from EEPROM address
 1b8:	61 e0       	ldi	r22, 0x01	; 1
 1ba:	25 34       	cpi	r18, 0x45	; 69
 1bc:	09 f0       	breq	.+2      	; 0x1c0 <__stack+0xe1>
 1be:	60 e0       	ldi	r22, 0x00	; 0
			(localData == 't') |	// Change the threshold setting
			(localData == 'd') |	// Change the delay before sleep
			(localData == 'z') |	// Force sleep in ~35ms
			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
			(localData == 'w') |	// Write buffered byte to ADXL362 register
			(localData == 'r') |	// Read ADXL362 register
 1c0:	64 2b       	or	r22, r20
	
// If the mode is currently null, and the character entered is a valid mode,
//   let's activate that mode. In some cases, we want immediate action, and
//   then to return to null mode.
	else if ((mode == ' ')&(
			(localData == 't') |	// Change the threshold setting
 1c2:	41 e0       	ldi	r20, 0x01	; 1
 1c4:	7c e9       	ldi	r23, 0x9C	; 156
 1c6:	72 0f       	add	r23, r18
 1c8:	72 30       	cpi	r23, 0x02	; 2
 1ca:	08 f0       	brcs	.+2      	; 0x1ce <__stack+0xef>
 1cc:	40 e0       	ldi	r20, 0x00	; 0
			(localData == 'd') |	// Change the delay before sleep
			(localData == 'z') |	// Force sleep in ~35ms
			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
			(localData == 'w') |	// Write buffered byte to ADXL362 register
			(localData == 'r') |	// Read ADXL362 register
			(localData == 'e') |	// Write buffered byte to EEPROM address
 1ce:	46 2b       	or	r20, r22
			(localData == 'E') |	// Read byte from EEPROM address
			(localData == 'p') |	// Read pin level (pins on header only)
			(localData == 'H') |	// Set pin high (pins on header only)
 1d0:	71 e0       	ldi	r23, 0x01	; 1
 1d2:	58 34       	cpi	r21, 0x48	; 72
 1d4:	09 f0       	breq	.+2      	; 0x1d8 <__stack+0xf9>
 1d6:	70 e0       	ldi	r23, 0x00	; 0
			(localData == 'z') |	// Force sleep in ~35ms
			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
			(localData == 'w') |	// Write buffered byte to ADXL362 register
			(localData == 'r') |	// Read ADXL362 register
			(localData == 'e') |	// Write buffered byte to EEPROM address
			(localData == 'E') |	// Read byte from EEPROM address
 1d8:	74 2b       	or	r23, r20
//   then to return to null mode.
	else if ((mode == ' ')&(
			(localData == 't') |	// Change the threshold setting
			(localData == 'd') |	// Change the delay before sleep
			(localData == 'z') |	// Force sleep in ~35ms
			(localData == 'b') |	// Buffer a byte for EEPROM or ADXL write
 1da:	61 e0       	ldi	r22, 0x01	; 1
 1dc:	42 2f       	mov	r20, r18
 1de:	4f 7e       	andi	r20, 0xEF	; 239
 1e0:	42 36       	cpi	r20, 0x62	; 98
 1e2:	09 f0       	breq	.+2      	; 0x1e6 <__stack+0x107>
 1e4:	60 e0       	ldi	r22, 0x00	; 0
			(localData == 'w') |	// Write buffered byte to ADXL362 register
			(localData == 'r') |	// Read ADXL362 register
			(localData == 'e') |	// Write buffered byte to EEPROM address
			(localData == 'E') |	// Read byte from EEPROM address
			(localData == 'p') |	// Read pin level (pins on header only)
 1e6:	67 2b       	or	r22, r23
 1e8:	41 e0       	ldi	r20, 0x01	; 1
 1ea:	50 37       	cpi	r21, 0x70	; 112
 1ec:	09 f0       	breq	.+2      	; 0x1f0 <__stack+0x111>
 1ee:	40 e0       	ldi	r20, 0x00	; 0
			(localData == 'H') |	// Set pin high (pins on header only)
 1f0:	46 2b       	or	r20, r22
	}
	
// If the mode is currently null, and the character entered is a valid mode,
//   let's activate that mode. In some cases, we want immediate action, and
//   then to return to null mode.
	else if ((mode == ' ')&(
 1f2:	79 f0       	breq	.+30     	; 0x212 <__stack+0x133>
 1f4:	33 23       	and	r19, r19
 1f6:	69 f0       	breq	.+26     	; 0x212 <__stack+0x133>
			(localData == 'p') |	// Read pin level (pins on header only)
			(localData == 'H') |	// Set pin high (pins on header only)
			(localData == 'L')		// Set pin low (pins on header only)
			))
	{
		mode = localData;
 1f8:	20 93 60 00 	sts	0x0060, r18
		// Most of the time, we need more information from the user. SOMETIMES,
		//   we may want to take immediate action. ATM, only a 'z' spurs that,
		//   indicating to the device that we want it to go to sleep post-haste
		//   and not buffer more data. Future immediate commands should be
		//   added here.
	    if (mode == 'z')
 1fc:	99 23       	and	r25, r25
 1fe:	09 f4       	brne	.+2      	; 0x202 <__stack+0x123>
 200:	af c0       	rjmp	.+350    	; 0x360 <__stack+0x281>
		{
			TCNT1 = 65500;	// Set TCNT1 to *almost* overflowing. Sleep will
 202:	8c ed       	ldi	r24, 0xDC	; 220
 204:	9f ef       	ldi	r25, 0xFF	; 255
 206:	9d bd       	out	0x2d, r25	; 45
 208:	8c bd       	out	0x2c, r24	; 44
							//   occur right after an overflow of TCNT1.
			mode = ' ';		// Clear mode for later.
 20a:	80 e2       	ldi	r24, 0x20	; 32
 20c:	80 93 60 00 	sts	0x0060, r24
 210:	08 95       	ret
				(mode == 'd')|\
				(mode == 'w')|\
				(mode == 'r')|\
				(mode == 'e')|\
				(mode == 'E')|\
				(mode == 'p')|\
 212:	98 2f       	mov	r25, r24
 214:	9b 7f       	andi	r25, 0xFB	; 251
	else if (	(mode == 't')|\
				(mode == 'd')|\
				(mode == 'w')|\
				(mode == 'r')|\
				(mode == 'e')|\
				(mode == 'E')|\
 216:	51 e0       	ldi	r21, 0x01	; 1
 218:	85 34       	cpi	r24, 0x45	; 69
 21a:	09 f0       	breq	.+2      	; 0x21e <__stack+0x13f>
 21c:	50 e0       	ldi	r21, 0x00	; 0
// Mode handler. Depending on the mode, the current input character should
//   be handled differently. Code for handling what happens before a user
//   has finished inputting a number goes here.
	else if (	(mode == 't')|\
				(mode == 'd')|\
				(mode == 'w')|\
 21e:	31 e0       	ldi	r19, 0x01	; 1
 220:	87 37       	cpi	r24, 0x77	; 119
 222:	09 f0       	breq	.+2      	; 0x226 <__stack+0x147>
 224:	30 e0       	ldi	r19, 0x00	; 0
				(mode == 'r')|\
				(mode == 'e')|\
 226:	35 2b       	or	r19, r21
		}
	}
// Mode handler. Depending on the mode, the current input character should
//   be handled differently. Code for handling what happens before a user
//   has finished inputting a number goes here.
	else if (	(mode == 't')|\
 228:	51 e0       	ldi	r21, 0x01	; 1
 22a:	4c e9       	ldi	r20, 0x9C	; 156
 22c:	48 0f       	add	r20, r24
 22e:	42 30       	cpi	r20, 0x02	; 2
 230:	08 f0       	brcs	.+2      	; 0x234 <__stack+0x155>
 232:	50 e0       	ldi	r21, 0x00	; 0
				(mode == 'd')|\
				(mode == 'w')|\
				(mode == 'r')|\
				(mode == 'e')|\
				(mode == 'E')|\
 234:	53 2b       	or	r21, r19
				(mode == 'p')|\
				(mode == 'H')|\
 236:	41 e0       	ldi	r20, 0x01	; 1
 238:	98 34       	cpi	r25, 0x48	; 72
 23a:	09 f0       	breq	.+2      	; 0x23e <__stack+0x15f>
 23c:	40 e0       	ldi	r20, 0x00	; 0
				(mode == 'd')|\
				(mode == 'w')|\
				(mode == 'r')|\
				(mode == 'e')|\
				(mode == 'E')|\
				(mode == 'p')|\
 23e:	45 2b       	or	r20, r21
				(mode == 'H')|\
				(mode == 'L')|\
				(mode == 'b'))
 240:	31 e0       	ldi	r19, 0x01	; 1
 242:	58 2f       	mov	r21, r24
 244:	5f 7e       	andi	r21, 0xEF	; 239
 246:	52 36       	cpi	r21, 0x62	; 98
 248:	09 f0       	breq	.+2      	; 0x24c <__stack+0x16d>
 24a:	30 e0       	ldi	r19, 0x00	; 0
				(mode == 'w')|\
				(mode == 'r')|\
				(mode == 'e')|\
				(mode == 'E')|\
				(mode == 'p')|\
				(mode == 'H')|\
 24c:	34 2b       	or	r19, r20
		}
	}
// Mode handler. Depending on the mode, the current input character should
//   be handled differently. Code for handling what happens before a user
//   has finished inputting a number goes here.
	else if (	(mode == 't')|\
 24e:	19 f4       	brne	.+6      	; 0x256 <__stack+0x177>
				(mode == 'd')|\
				(mode == 'w')|\
				(mode == 'r')|\
				(mode == 'e')|\
				(mode == 'E')|\
				(mode == 'p')|\
 250:	90 37       	cpi	r25, 0x70	; 112
 252:	09 f0       	breq	.+2      	; 0x256 <__stack+0x177>
 254:	81 c0       	rjmp	.+258    	; 0x358 <__stack+0x279>
		//   pin. Pins available for this are PB0:3 and PD6; we'll respond
		//   based on a numerical input 0-3 or 6. Other values print an
		//   error message. Note that no cr/lf is needed to complete this
		//   operation- it just...ends, as soon as another character has
		//   been received.
		if (mode == 'p')
 256:	80 37       	cpi	r24, 0x70	; 112
 258:	61 f5       	brne	.+88     	; 0x2b2 <__stack+0x1d3>
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 25a:	80 e2       	ldi	r24, 0x20	; 32
 25c:	80 93 60 00 	sts	0x0060, r24
			switch(localData)
 260:	22 33       	cpi	r18, 0x32	; 50
 262:	d1 f0       	breq	.+52     	; 0x298 <__stack+0x1b9>
 264:	50 f4       	brcc	.+20     	; 0x27a <__stack+0x19b>
 266:	20 33       	cpi	r18, 0x30	; 48
 268:	99 f0       	breq	.+38     	; 0x290 <__stack+0x1b1>
 26a:	21 33       	cpi	r18, 0x31	; 49
 26c:	09 f0       	breq	.+2      	; 0x270 <__stack+0x191>
 26e:	77 c0       	rjmp	.+238    	; 0x35e <__stack+0x27f>
				DDRB &= ~(1<<PB0);							// make pin input
				serialWriteChar('0'+((PINB & (1<<PB0))>>PB0));    // isolate bit and
														    //   read it out
				break;
				case '1':
				DDRB &= ~(1<<PB1);
 270:	b9 98       	cbi	0x17, 1	; 23
				serialWriteChar('0'+((PINB & (1<<PB1))>>PB1));
 272:	86 b3       	in	r24, 0x16	; 22
 274:	86 95       	lsr	r24
 276:	81 70       	andi	r24, 0x01	; 1
 278:	14 c0       	rjmp	.+40     	; 0x2a2 <__stack+0x1c3>
		//   operation- it just...ends, as soon as another character has
		//   been received.
		if (mode == 'p')
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
			switch(localData)
 27a:	23 33       	cpi	r18, 0x33	; 51
 27c:	a1 f0       	breq	.+40     	; 0x2a6 <__stack+0x1c7>
 27e:	26 33       	cpi	r18, 0x36	; 54
 280:	09 f0       	breq	.+2      	; 0x284 <__stack+0x1a5>
 282:	6d c0       	rjmp	.+218    	; 0x35e <__stack+0x27f>
				case '3':
				DDRB &= ~(1<<PB3);
				serialWriteChar('0'+((PINB & (1<<PB3))>>PB3));
				break;
				case '6':
				DDRD &= ~(1<<PD6);
 284:	8e 98       	cbi	0x11, 6	; 17
				serialWriteChar('0'+((PIND & (1<<PD6))>>PD6));
 286:	80 b3       	in	r24, 0x10	; 16
 288:	86 fb       	bst	r24, 6
 28a:	88 27       	eor	r24, r24
 28c:	80 f9       	bld	r24, 0
 28e:	09 c0       	rjmp	.+18     	; 0x2a2 <__stack+0x1c3>
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
			switch(localData)
			{
				case '0':
				DDRB &= ~(1<<PB0);							// make pin input
 290:	b8 98       	cbi	0x17, 0	; 23
				serialWriteChar('0'+((PINB & (1<<PB0))>>PB0));    // isolate bit and
 292:	86 b3       	in	r24, 0x16	; 22
 294:	81 70       	andi	r24, 0x01	; 1
 296:	05 c0       	rjmp	.+10     	; 0x2a2 <__stack+0x1c3>
				case '1':
				DDRB &= ~(1<<PB1);
				serialWriteChar('0'+((PINB & (1<<PB1))>>PB1));
				break;
				case '2':
				DDRB &= ~(1<<PB2);
 298:	ba 98       	cbi	0x17, 2	; 23
				serialWriteChar('0'+((PINB & (1<<PB2))>>PB2));
 29a:	86 b3       	in	r24, 0x16	; 22
 29c:	82 fb       	bst	r24, 2
 29e:	88 27       	eor	r24, r24
 2a0:	80 f9       	bld	r24, 0
				serialWriteChar('0'+((PINB & (1<<PB0))>>PB0));    // isolate bit and
														    //   read it out
				break;
				case '1':
				DDRB &= ~(1<<PB1);
				serialWriteChar('0'+((PINB & (1<<PB1))>>PB1));
 2a2:	80 5d       	subi	r24, 0xD0	; 208
 2a4:	5e c0       	rjmp	.+188    	; 0x362 <serialWriteChar>
				case '2':
				DDRB &= ~(1<<PB2);
				serialWriteChar('0'+((PINB & (1<<PB2))>>PB2));
				break;
				case '3':
				DDRB &= ~(1<<PB3);
 2a6:	bb 98       	cbi	0x17, 3	; 23
				serialWriteChar('0'+((PINB & (1<<PB3))>>PB3));
 2a8:	86 b3       	in	r24, 0x16	; 22
 2aa:	83 fb       	bst	r24, 3
 2ac:	88 27       	eor	r24, r24
 2ae:	80 f9       	bld	r24, 0
 2b0:	f8 cf       	rjmp	.-16     	; 0x2a2 <__stack+0x1c3>
		}
		// case 'H': indicates user wants to set the state of a given pin to
		//   high. Pins available for this are PB0:3 and PD6; we'll respond
		//   based on a numerical input 0-3 or 6. Other values print an
		//   error message.
		else if (mode == 'H')
 2b2:	88 34       	cpi	r24, 0x48	; 72
 2b4:	f9 f4       	brne	.+62     	; 0x2f4 <__stack+0x215>
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 2b6:	80 e2       	ldi	r24, 0x20	; 32
 2b8:	80 93 60 00 	sts	0x0060, r24
			switch(localData)
 2bc:	22 33       	cpi	r18, 0x32	; 50
 2be:	a1 f0       	breq	.+40     	; 0x2e8 <__stack+0x209>
 2c0:	40 f4       	brcc	.+16     	; 0x2d2 <__stack+0x1f3>
 2c2:	20 33       	cpi	r18, 0x30	; 48
 2c4:	71 f0       	breq	.+28     	; 0x2e2 <__stack+0x203>
 2c6:	21 33       	cpi	r18, 0x31	; 49
 2c8:	09 f0       	breq	.+2      	; 0x2cc <__stack+0x1ed>
 2ca:	49 c0       	rjmp	.+146    	; 0x35e <__stack+0x27f>
				case '0':
				DDRB |= (1<<PB0);	// make pin an output
				PORTB |= (1<<PB0);  // set pin high
				break;
				case '1':
				DDRB |= (1<<PB1);
 2cc:	b9 9a       	sbi	0x17, 1	; 23
				PORTB |= (1<<PB1);
 2ce:	c1 9a       	sbi	0x18, 1	; 24
				break;
 2d0:	08 95       	ret
		//   based on a numerical input 0-3 or 6. Other values print an
		//   error message.
		else if (mode == 'H')
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
			switch(localData)
 2d2:	23 33       	cpi	r18, 0x33	; 51
 2d4:	61 f0       	breq	.+24     	; 0x2ee <__stack+0x20f>
 2d6:	26 33       	cpi	r18, 0x36	; 54
 2d8:	09 f0       	breq	.+2      	; 0x2dc <__stack+0x1fd>
 2da:	41 c0       	rjmp	.+130    	; 0x35e <__stack+0x27f>
				case '3':
				DDRB |= (1<<PB3);
				PORTB |= (1<<PB3);
				break;
				case '6':
				DDRD |= (1<<PD6);
 2dc:	8e 9a       	sbi	0x11, 6	; 17
				PORTD |= (1<<PD6);
 2de:	96 9a       	sbi	0x12, 6	; 18
				break;
 2e0:	08 95       	ret
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
			switch(localData)
			{
				case '0':
				DDRB |= (1<<PB0);	// make pin an output
 2e2:	b8 9a       	sbi	0x17, 0	; 23
				PORTB |= (1<<PB0);  // set pin high
 2e4:	c0 9a       	sbi	0x18, 0	; 24
				break;
 2e6:	08 95       	ret
				case '1':
				DDRB |= (1<<PB1);
				PORTB |= (1<<PB1);
				break;
				case '2':
				DDRB |= (1<<PB2);
 2e8:	ba 9a       	sbi	0x17, 2	; 23
				PORTB |= (1<<PB2);
 2ea:	c2 9a       	sbi	0x18, 2	; 24
				break;
 2ec:	08 95       	ret
				case '3':
				DDRB |= (1<<PB3);
 2ee:	bb 9a       	sbi	0x17, 3	; 23
				PORTB |= (1<<PB3);
 2f0:	c3 9a       	sbi	0x18, 3	; 24
				break;
 2f2:	08 95       	ret
		}
		// case 'L': indicates user wants to set the state of a given pin to
		//   low. Pins available for this are PB0:3 and PD6; we'll respond
		//   based on a numerical input 0-3 or 6. Other values print an
		//   error message.
		else if (mode == 'L')
 2f4:	8c 34       	cpi	r24, 0x4C	; 76
 2f6:	e9 f4       	brne	.+58     	; 0x332 <__stack+0x253>
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
 2f8:	80 e2       	ldi	r24, 0x20	; 32
 2fa:	80 93 60 00 	sts	0x0060, r24
			switch(localData)
 2fe:	22 33       	cpi	r18, 0x32	; 50
 300:	91 f0       	breq	.+36     	; 0x326 <__stack+0x247>
 302:	38 f4       	brcc	.+14     	; 0x312 <__stack+0x233>
 304:	20 33       	cpi	r18, 0x30	; 48
 306:	61 f0       	breq	.+24     	; 0x320 <__stack+0x241>
 308:	21 33       	cpi	r18, 0x31	; 49
 30a:	49 f5       	brne	.+82     	; 0x35e <__stack+0x27f>
				case '0':
				DDRB |= (1<<PB0);	// make pin an output
				PORTB &= ~(1<<PB0); // set pin low
				break;
				case '1':
				DDRB |= (1<<PB1);
 30c:	b9 9a       	sbi	0x17, 1	; 23
				PORTB &= ~(1<<PB1);
 30e:	c1 98       	cbi	0x18, 1	; 24
				break;
 310:	08 95       	ret
		//   based on a numerical input 0-3 or 6. Other values print an
		//   error message.
		else if (mode == 'L')
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
			switch(localData)
 312:	23 33       	cpi	r18, 0x33	; 51
 314:	59 f0       	breq	.+22     	; 0x32c <__stack+0x24d>
 316:	26 33       	cpi	r18, 0x36	; 54
 318:	11 f5       	brne	.+68     	; 0x35e <__stack+0x27f>
				case '3':
				DDRB |= (1<<PB3);
				PORTB &= ~(1<<PB3);
				break;
				case '6':
				DDRD |= (1<<PD6);
 31a:	8e 9a       	sbi	0x11, 6	; 17
				PORTD &= ~(1<<PD6);
 31c:	96 98       	cbi	0x12, 6	; 18
				break;
 31e:	08 95       	ret
		{
			mode = ' ';   // clear mode. We'll do this regardless of outcome.
			switch(localData)
			{
				case '0':
				DDRB |= (1<<PB0);	// make pin an output
 320:	b8 9a       	sbi	0x17, 0	; 23
				PORTB &= ~(1<<PB0); // set pin low
 322:	c0 98       	cbi	0x18, 0	; 24
				break;
 324:	08 95       	ret
				case '1':
				DDRB |= (1<<PB1);
				PORTB &= ~(1<<PB1);
				break;
				case '2':
				DDRB |= (1<<PB2);
 326:	ba 9a       	sbi	0x17, 2	; 23
				PORTB &= ~(1<<PB2);
 328:	c2 98       	cbi	0x18, 2	; 24
				break;
 32a:	08 95       	ret
				case '3':
				DDRB |= (1<<PB3);
 32c:	bb 9a       	sbi	0x17, 3	; 23
				PORTB &= ~(1<<PB3);
 32e:	c3 98       	cbi	0x18, 3	; 24
				break;
 330:	08 95       	ret
				break;
			}
		}
		// Case numeric value AND some other state not involving pins-
		//   store the value into input buffer.
		else if (('0' <= localData) & (localData <= '9'))
 332:	80 ed       	ldi	r24, 0xD0	; 208
 334:	82 0f       	add	r24, r18
 336:	8a 30       	cpi	r24, 0x0A	; 10
 338:	78 f4       	brcc	.+30     	; 0x358 <__stack+0x279>
		{
			inputBufferValue *= 10;
 33a:	80 91 6f 00 	lds	r24, 0x006F
 33e:	90 91 70 00 	lds	r25, 0x0070
 342:	6a e0       	ldi	r22, 0x0A	; 10
 344:	70 e0       	ldi	r23, 0x00	; 0
 346:	97 d1       	rcall	.+814    	; 0x676 <__mulhi3>
			inputBufferValue += (localData - '0');
 348:	82 0f       	add	r24, r18
 34a:	91 1d       	adc	r25, r1
 34c:	c0 97       	sbiw	r24, 0x30	; 48
 34e:	90 93 70 00 	sts	0x0070, r25
 352:	80 93 6f 00 	sts	0x006F, r24
 356:	08 95       	ret
		}
		// Case ANYTHING ELSE entered by user- clear mode, and whine a bit
		//   so they know the screwed up.
		else
		{
			mode = ' ';
 358:	80 e2       	ldi	r24, 0x20	; 32
 35a:	80 93 60 00 	sts	0x0060, r24
			abortInput();
 35e:	b3 ce       	rjmp	.-666    	; 0xc6 <abortInput>
 360:	08 95       	ret

00000362 <serialWriteChar>:

// Print a single character out to the serial port. Blocks until write has
//   completed- is that a mistake?
void serialWriteChar(char data)
{
	UDR = data;
 362:	8c b9       	out	0x0c, r24	; 12
	while ((UCSRA & (1<<TXC))==0){}   // Wait for the transmit to finish.
 364:	5e 9b       	sbis	0x0b, 6	; 11
 366:	fe cf       	rjmp	.-4      	; 0x364 <serialWriteChar+0x2>
	UCSRA |= (1<<TXC);				// Clear the "transmit complete" flag.
 368:	5e 9a       	sbi	0x0b, 6	; 11
 36a:	08 95       	ret

0000036c <serialNewline>:
	serialNewline();
}

void serialNewline(void)
{
	serialWriteChar((char)'\n');
 36c:	8a e0       	ldi	r24, 0x0A	; 10
 36e:	f9 df       	rcall	.-14     	; 0x362 <serialWriteChar>
	serialWriteChar((char)'\r');
 370:	8d e0       	ldi	r24, 0x0D	; 13
 372:	f7 cf       	rjmp	.-18     	; 0x362 <serialWriteChar>

00000374 <serialWrite>:

// serialWrite() takes a pointer to a string and iterates over that string
//   until it finds the C end-of-string character ('\0'). It's a blocking
//   operation and does not return until the print operation is completed.
void serialWrite(char* data)
{
 374:	cf 93       	push	r28
 376:	df 93       	push	r29
 378:	ec 01       	movw	r28, r24
	do
	{
		serialWriteChar((char)*data);   // Print the first character.
 37a:	89 91       	ld	r24, Y+
 37c:	f2 df       	rcall	.-28     	; 0x362 <serialWriteChar>
		data++;							// Increment the pointer.
	} while (*data != '\0');			// Check for the end of the string.
 37e:	88 81       	ld	r24, Y
 380:	81 11       	cpse	r24, r1
 382:	fb cf       	rjmp	.-10     	; 0x37a <serialWrite+0x6>
	serialNewline();
}
 384:	df 91       	pop	r29
 386:	cf 91       	pop	r28
	do
	{
		serialWriteChar((char)*data);   // Print the first character.
		data++;							// Increment the pointer.
	} while (*data != '\0');			// Check for the end of the string.
	serialNewline();
 388:	f1 cf       	rjmp	.-30     	; 0x36c <serialNewline>

0000038a <serialWriteInt>:
}

// Convert a 16-bit unsigned value into ASCII characters and dump it out
//   to the serial port.
void serialWriteInt(unsigned int data)
{	
 38a:	0f 93       	push	r16
 38c:	1f 93       	push	r17
 38e:	cf 93       	push	r28
 390:	df 93       	push	r29
 392:	cd b7       	in	r28, 0x3d	; 61
 394:	dd 27       	eor	r29, r29
 396:	c3 50       	subi	r28, 0x03	; 3
 398:	cd bf       	out	0x3d, r28	; 61
 39a:	9c 01       	movw	r18, r24
	uint8_t huns = 0;
	uint8_t tens = 0;
	uint8_t ones = 0;
	// This is an awkward shifting/dividing method of isolating the individual
	//   digits of the number. I'm sure there's a better way, but done is.
	tenth = (data/10000);
 39c:	60 e1       	ldi	r22, 0x10	; 16
 39e:	77 e2       	ldi	r23, 0x27	; 39
 3a0:	7b d1       	rcall	.+758    	; 0x698 <__udivmodhi4>
 3a2:	e6 2f       	mov	r30, r22
 3a4:	97 2f       	mov	r25, r23
	data -= tenth*10000;
 3a6:	86 2f       	mov	r24, r22
 3a8:	60 ef       	ldi	r22, 0xF0	; 240
 3aa:	78 ed       	ldi	r23, 0xD8	; 216
 3ac:	64 d1       	rcall	.+712    	; 0x676 <__mulhi3>
 3ae:	28 0f       	add	r18, r24
 3b0:	39 1f       	adc	r19, r25
	thou = (uint8_t)(data/1000);
 3b2:	c9 01       	movw	r24, r18
 3b4:	68 ee       	ldi	r22, 0xE8	; 232
 3b6:	73 e0       	ldi	r23, 0x03	; 3
 3b8:	6f d1       	rcall	.+734    	; 0x698 <__udivmodhi4>
 3ba:	16 2f       	mov	r17, r22
 3bc:	97 2f       	mov	r25, r23
	data -= (uint16_t)thou*1000;
 3be:	86 2f       	mov	r24, r22
 3c0:	68 ee       	ldi	r22, 0xE8	; 232
 3c2:	73 e0       	ldi	r23, 0x03	; 3
 3c4:	58 d1       	rcall	.+688    	; 0x676 <__mulhi3>
 3c6:	28 1b       	sub	r18, r24
 3c8:	39 0b       	sbc	r19, r25
	huns = (uint8_t)(data/100);
 3ca:	c9 01       	movw	r24, r18
 3cc:	64 e6       	ldi	r22, 0x64	; 100
 3ce:	70 e0       	ldi	r23, 0x00	; 0
 3d0:	63 d1       	rcall	.+710    	; 0x698 <__udivmodhi4>
 3d2:	ab 01       	movw	r20, r22
	data -= (uint16_t)huns*100;
 3d4:	cb 01       	movw	r24, r22
 3d6:	99 27       	eor	r25, r25
 3d8:	64 e6       	ldi	r22, 0x64	; 100
 3da:	70 e0       	ldi	r23, 0x00	; 0
 3dc:	4c d1       	rcall	.+664    	; 0x676 <__mulhi3>
 3de:	b9 01       	movw	r22, r18
 3e0:	68 1b       	sub	r22, r24
 3e2:	79 0b       	sbc	r23, r25
 3e4:	cb 01       	movw	r24, r22
	tens = (uint8_t)(data/10);
 3e6:	6a e0       	ldi	r22, 0x0A	; 10
 3e8:	70 e0       	ldi	r23, 0x00	; 0
 3ea:	56 d1       	rcall	.+684    	; 0x698 <__udivmodhi4>
 3ec:	08 2f       	mov	r16, r24
	thou += 48;
	huns += 48;
	tens += 48;
	ones += 48;
	// Write the individual digits out, followed by a line feed and CR.
	serialWriteChar(tenth);
 3ee:	80 e3       	ldi	r24, 0x30	; 48
 3f0:	8e 0f       	add	r24, r30
 3f2:	49 83       	std	Y+1, r20	; 0x01
 3f4:	5a 83       	std	Y+2, r21	; 0x02
 3f6:	6b 83       	std	Y+3, r22	; 0x03
 3f8:	b4 df       	rcall	.-152    	; 0x362 <serialWriteChar>
	serialWriteChar(thou);
 3fa:	80 e3       	ldi	r24, 0x30	; 48
 3fc:	81 0f       	add	r24, r17
 3fe:	b1 df       	rcall	.-158    	; 0x362 <serialWriteChar>
	serialWriteChar(huns);
 400:	49 81       	ldd	r20, Y+1	; 0x01
 402:	80 e3       	ldi	r24, 0x30	; 48
 404:	84 0f       	add	r24, r20
 406:	ad df       	rcall	.-166    	; 0x362 <serialWriteChar>
	serialWriteChar(tens);
 408:	6b 81       	ldd	r22, Y+3	; 0x03
 40a:	80 e3       	ldi	r24, 0x30	; 48
 40c:	86 0f       	add	r24, r22
 40e:	a9 df       	rcall	.-174    	; 0x362 <serialWriteChar>
	serialWriteChar(ones);
 410:	80 e3       	ldi	r24, 0x30	; 48
 412:	80 0f       	add	r24, r16
 414:	a6 df       	rcall	.-180    	; 0x362 <serialWriteChar>
	serialNewline();
}
 416:	cd 5f       	subi	r28, 0xFD	; 253
 418:	cd bf       	out	0x3d, r28	; 61
 41a:	df 91       	pop	r29
 41c:	cf 91       	pop	r28
 41e:	1f 91       	pop	r17
 420:	0f 91       	pop	r16
	serialWriteChar(tenth);
	serialWriteChar(thou);
	serialWriteChar(huns);
	serialWriteChar(tens);
	serialWriteChar(ones);
	serialNewline();
 422:	a4 cf       	rjmp	.-184    	; 0x36c <serialNewline>

00000424 <__vector_5>:
//   after it's been on for a certain time. Timer1 has been set up to tick
//   on clock/1024, which is ~1ms ticks; it's a 16-bit overflow, so left to
//   it's own devices, it will overflow every 65536 ticks, or after a bit
//   more than a minute. To shorten that time, we prime TCNT1
ISR(TIMER1_OVF_vect)
{
 424:	1f 92       	push	r1
 426:	0f 92       	push	r0
 428:	0f b6       	in	r0, 0x3f	; 63
 42a:	0f 92       	push	r0
 42c:	11 24       	eor	r1, r1
 42e:	8f 93       	push	r24
	sleepyTime = TRUE;
 430:	81 e0       	ldi	r24, 0x01	; 1
 432:	80 93 6d 00 	sts	0x006D, r24
}
 436:	8f 91       	pop	r24
 438:	0f 90       	pop	r0
 43a:	0f be       	out	0x3f, r0	; 63
 43c:	0f 90       	pop	r0
 43e:	1f 90       	pop	r1
 440:	18 95       	reti

00000442 <__vector_1>:
// INT0 ISR- This is one way the processor can wake from sleep. INT0 is tied
//   externally to the RX pin, so traffic on the serial receive line will
//   wake up the part when it is asleep. Note that the receive interrupt
//   can't wake the processor from sleep- don't try!
ISR(INT0_vect)
{
 442:	1f 92       	push	r1
 444:	0f 92       	push	r0
 446:	0f b6       	in	r0, 0x3f	; 63
 448:	0f 92       	push	r0
 44a:	11 24       	eor	r1, r1
 44c:	8f 93       	push	r24
 44e:	9f 93       	push	r25
	TCNT1 = t1Offset;				// Reset our counter for on-time.
 450:	80 91 71 00 	lds	r24, 0x0071
 454:	90 91 72 00 	lds	r25, 0x0072
 458:	9d bd       	out	0x2d, r25	; 45
 45a:	8c bd       	out	0x2c, r24	; 44
	sleepyTime = FALSE;				// Indicate wakefulness to main loop.
 45c:	10 92 6d 00 	sts	0x006D, r1
	GIMSK = (0<<INT0)|(0<<INT1);	// Disable INT pins while we're awake.
 460:	1b be       	out	0x3b, r1	; 59
									//  This is important b/c the INT pins
									//  cause an interrupt on LOW rather
									//  than on an edge, so the interrupt
									//  will continue to fire as long as
									//  the pin is low unless it is disabled.
}
 462:	9f 91       	pop	r25
 464:	8f 91       	pop	r24
 466:	0f 90       	pop	r0
 468:	0f be       	out	0x3f, r0	; 63
 46a:	0f 90       	pop	r0
 46c:	1f 90       	pop	r1
 46e:	18 95       	reti

00000470 <__vector_2>:

// INT1 ISR- this is the primary way the processor wakes from sleep. INT1 is
//   tied to the interrupt output pin on the ADXL362, which goes low when
//   motion is detected.
ISR(INT1_vect)
{
 470:	1f 92       	push	r1
 472:	0f 92       	push	r0
 474:	0f b6       	in	r0, 0x3f	; 63
 476:	0f 92       	push	r0
 478:	11 24       	eor	r1, r1
 47a:	8f 93       	push	r24
 47c:	9f 93       	push	r25
	TCNT1 = t1Offset;				// See INT0 ISR for details.
 47e:	80 91 71 00 	lds	r24, 0x0071
 482:	90 91 72 00 	lds	r25, 0x0072
 486:	9d bd       	out	0x2d, r25	; 45
 488:	8c bd       	out	0x2c, r24	; 44
	sleepyTime = FALSE;
 48a:	10 92 6d 00 	sts	0x006D, r1
	GIMSK = (0<<INT0)|(0<<INT1); 
 48e:	1b be       	out	0x3b, r1	; 59
}
 490:	9f 91       	pop	r25
 492:	8f 91       	pop	r24
 494:	0f 90       	pop	r0
 496:	0f be       	out	0x3f, r0	; 63
 498:	0f 90       	pop	r0
 49a:	1f 90       	pop	r1
 49c:	18 95       	reti

0000049e <USART_RX_vect>:

// USART_RX ISR- gets called when the processor is awake and a complete
//   byte (including stop bit) has been received by the USART. This
//   interrupt CANNOT be used to wake the processor, so don't try it.
ISR(USART_RX_vect)
{
 49e:	1f 92       	push	r1
 4a0:	0f 92       	push	r0
 4a2:	0f b6       	in	r0, 0x3f	; 63
 4a4:	0f 92       	push	r0
 4a6:	11 24       	eor	r1, r1
 4a8:	8f 93       	push	r24
 4aa:	9f 93       	push	r25
	TCNT1 = t1Offset;	// Reset the wakefulness timer, so the processor
 4ac:	80 91 71 00 	lds	r24, 0x0071
 4b0:	90 91 72 00 	lds	r25, 0x0072
 4b4:	9d bd       	out	0x2d, r25	; 45
 4b6:	8c bd       	out	0x2c, r24	; 44
						//   doesn't go to sleep while the user is
						//   interacting with it.
	serialRxData = UDR; // Pass the data back to the main loop for parsing.
 4b8:	8c b1       	in	r24, 0x0c	; 12
 4ba:	80 93 6c 00 	sts	0x006C, r24
}
 4be:	9f 91       	pop	r25
 4c0:	8f 91       	pop	r24
 4c2:	0f 90       	pop	r0
 4c4:	0f be       	out	0x3f, r0	; 63
 4c6:	0f 90       	pop	r0
 4c8:	1f 90       	pop	r1
 4ca:	18 95       	reti

000004cc <ADXLReadByte>:
}

// Simple functions to assert chip select and copy data in and out of the
//   ADXL362. 
uint8_t ADXLReadByte(uint8_t addr)
{
 4cc:	cf 93       	push	r28
 4ce:	c8 2f       	mov	r28, r24
	PORTB &= !(1<<PB4);	
 4d0:	88 b3       	in	r24, 0x18	; 24
 4d2:	18 ba       	out	0x18, r1	; 24
	spiXfer((uint8_t)XL362_REG_READ);
 4d4:	8b e0       	ldi	r24, 0x0B	; 11
 4d6:	78 d0       	rcall	.+240    	; 0x5c8 <spiXfer>
	spiXfer(addr);
 4d8:	8c 2f       	mov	r24, r28
 4da:	76 d0       	rcall	.+236    	; 0x5c8 <spiXfer>
	addr = spiXfer(addr);
 4dc:	8c 2f       	mov	r24, r28
 4de:	74 d0       	rcall	.+232    	; 0x5c8 <spiXfer>
	PORTB |= (1<<PB4);
 4e0:	c4 9a       	sbi	0x18, 4	; 24
	return addr;
}
 4e2:	cf 91       	pop	r28
 4e4:	08 95       	ret

000004e6 <ADXLWriteByte>:

void ADXLWriteByte(uint8_t addr, uint8_t data)
{
 4e6:	1f 93       	push	r17
 4e8:	cf 93       	push	r28
 4ea:	df 93       	push	r29
 4ec:	1f 92       	push	r1
 4ee:	cd b7       	in	r28, 0x3d	; 61
 4f0:	dd 27       	eor	r29, r29
 4f2:	18 2f       	mov	r17, r24
	PORTB &= !(1<<PB4);
 4f4:	88 b3       	in	r24, 0x18	; 24
 4f6:	18 ba       	out	0x18, r1	; 24
	spiXfer((uint8_t)XL362_REG_WRITE);
 4f8:	8a e0       	ldi	r24, 0x0A	; 10
 4fa:	69 83       	std	Y+1, r22	; 0x01
 4fc:	65 d0       	rcall	.+202    	; 0x5c8 <spiXfer>
	spiXfer(addr);
 4fe:	81 2f       	mov	r24, r17
 500:	63 d0       	rcall	.+198    	; 0x5c8 <spiXfer>
	spiXfer(data);
 502:	69 81       	ldd	r22, Y+1	; 0x01
 504:	86 2f       	mov	r24, r22
 506:	60 d0       	rcall	.+192    	; 0x5c8 <spiXfer>
	PORTB |= (1<<PB4);
 508:	c4 9a       	sbi	0x18, 4	; 24
 50a:	0f 90       	pop	r0
 50c:	df 91       	pop	r29
 50e:	cf 91       	pop	r28
 510:	1f 91       	pop	r17
 512:	08 95       	ret

00000514 <ADXLConfig>:
//   the wake-on-shake type application.
void ADXLConfig(void)
{
	// Activity threshold level (0x20)-
	//   Defaults to 150mg; user can change this.
	ADXLWriteByte((uint8_t)XL362_THRESH_ACTH, EEPROMReadByte(ATHRESH));
 514:	80 e0       	ldi	r24, 0x00	; 0
 516:	3b d0       	rcall	.+118    	; 0x58e <EEPROMReadByte>
 518:	68 2f       	mov	r22, r24
 51a:	81 e2       	ldi	r24, 0x21	; 33
 51c:	e4 df       	rcall	.-56     	; 0x4e6 <ADXLWriteByte>
	ADXLWriteByte((uint8_t)XL362_THRESH_ACTL, EEPROMReadByte(ATHRESH + 1));
 51e:	81 e0       	ldi	r24, 0x01	; 1
 520:	36 d0       	rcall	.+108    	; 0x58e <EEPROMReadByte>
 522:	68 2f       	mov	r22, r24
 524:	80 e2       	ldi	r24, 0x20	; 32
 526:	df df       	rcall	.-66     	; 0x4e6 <ADXLWriteByte>
	// Inactivity threshold level (0x23)-
	//   Written to 50 to give a 50mg sleep detection level
	ADXLWriteByte((uint8_t)XL362_THRESH_INACTH, EEPROMReadByte(ITHRESH));
 528:	84 e0       	ldi	r24, 0x04	; 4
 52a:	31 d0       	rcall	.+98     	; 0x58e <EEPROMReadByte>
 52c:	68 2f       	mov	r22, r24
 52e:	84 e2       	ldi	r24, 0x24	; 36
 530:	da df       	rcall	.-76     	; 0x4e6 <ADXLWriteByte>
	ADXLWriteByte((uint8_t)XL362_THRESH_INACTL, EEPROMReadByte(ITHRESH+1));
 532:	85 e0       	ldi	r24, 0x05	; 5
 534:	2c d0       	rcall	.+88     	; 0x58e <EEPROMReadByte>
 536:	68 2f       	mov	r22, r24
 538:	83 e2       	ldi	r24, 0x23	; 35
 53a:	d5 df       	rcall	.-86     	; 0x4e6 <ADXLWriteByte>
	// Inactivity timer (0x25)-
	//   Written to 15; wait 15 samples (~2.5 seconds) before going back
	//   to sleep.
	ADXLWriteByte((uint8_t)XL362_TIME_INACTH, EEPROMReadByte(ITIME));
 53c:	86 e0       	ldi	r24, 0x06	; 6
 53e:	27 d0       	rcall	.+78     	; 0x58e <EEPROMReadByte>
 540:	68 2f       	mov	r22, r24
 542:	86 e2       	ldi	r24, 0x26	; 38
 544:	d0 df       	rcall	.-96     	; 0x4e6 <ADXLWriteByte>
	ADXLWriteByte((uint8_t)XL362_TIME_INACTL, EEPROMReadByte(ITIME+1));	
 546:	87 e0       	ldi	r24, 0x07	; 7
 548:	22 d0       	rcall	.+68     	; 0x58e <EEPROMReadByte>
 54a:	68 2f       	mov	r22, r24
 54c:	85 e2       	ldi	r24, 0x25	; 37
 54e:	cb df       	rcall	.-106    	; 0x4e6 <ADXLWriteByte>
	//   Needs to be set to LOOP mode (5:4 = 11)
	//   We want referenced measurement mode for inactivity (3 = 1)
	//   We need to activate inactivity detection (2 = 1)
	//   We want referenced measurement mode for activity (1 = 1)
	//   We need to activate activity detection (0 = 1)
	ADXLWriteByte((uint8_t)XL362_ACT_INACT_CTL, (uint8_t)0xFF);
 550:	6f ef       	ldi	r22, 0xFF	; 255
 552:	87 e2       	ldi	r24, 0x27	; 39
 554:	c8 df       	rcall	.-112    	; 0x4e6 <ADXLWriteByte>
	// INT1 function map register (0x2A)-
	//   Needs to be set to "Active Low" (7 = 1)
	//   Needs to be set to activity mode (4 = 1)
	//   Other bits must be zero.
	ADXLWriteByte((uint8_t)XL362_INTMAP1, (uint8_t)0b10010000);
 556:	60 e9       	ldi	r22, 0x90	; 144
 558:	8a e2       	ldi	r24, 0x2A	; 42
 55a:	c5 df       	rcall	.-118    	; 0x4e6 <ADXLWriteByte>
	// Power control register (0x2D)-
	//   Needs to be set to wake mode (3 = 1)
	//   Need to turn on sampling mode (1:0 = 10)
	//   Other bits must be zero
	ADXLWriteByte((uint8_t)XL362_POWER_CTL, (uint8_t)0x0A);
 55c:	6a e0       	ldi	r22, 0x0A	; 10
 55e:	8d e2       	ldi	r24, 0x2D	; 45
 560:	c2 cf       	rjmp	.-124    	; 0x4e6 <ADXLWriteByte>

00000562 <EEPROMWriteByte>:

// 8-bit write to EEPROM. Since EEPROM writes can take rather a long time, we
//   want to disable interrupts to avoid any unforeseen register mashing.
void EEPROMWriteByte(uint8_t addr, uint8_t data)
{
	cli();							// Disable interrupts.
 562:	f8 94       	cli
	while (EECR & (1<<EEPE));		// Wait for in-progress EEPROM writes to
 564:	e1 99       	sbic	0x1c, 1	; 28
 566:	fe cf       	rjmp	.-4      	; 0x564 <EEPROMWriteByte+0x2>
									//  complete before using their resources.
	EECR = (0<<EEPM1) | (0<<EEPM0); // See datasheet for details on the hows
 568:	1c ba       	out	0x1c, r1	; 28
	EEAR = addr;					//  and whys of this write process.
 56a:	8e bb       	out	0x1e, r24	; 30
	EEDR = data;
 56c:	6d bb       	out	0x1d, r22	; 29
	EECR |= (1<<EEMPE);
 56e:	e2 9a       	sbi	0x1c, 2	; 28
	EECR |= (1<<EEPE);
 570:	e1 9a       	sbi	0x1c, 1	; 28
	sei();							// Re-enable interrupts once the write is
 572:	78 94       	sei
 574:	08 95       	ret

00000576 <EEPROMWriteWord>:
// Write a 16-bit value to EEPROM. Data is written big-endian. Note that
//   blocking while waiting for prior writes to EEPROM to complete is
//   handled in the byte read/write calls, which are called from here,
//   so blocking is NOT needed in this function.
void EEPROMWriteWord(uint8_t addr, uint16_t data)
{
 576:	cf 93       	push	r28
 578:	df 93       	push	r29
 57a:	c8 2f       	mov	r28, r24
 57c:	d6 2f       	mov	r29, r22
 57e:	67 2f       	mov	r22, r23
	uint16_t dataTemp = data>>8;				// Isolate the high byte.
	EEPROMWriteByte(addr, (uint8_t)dataTemp);   // Write high byte to EEPROM.
 580:	f0 df       	rcall	.-32     	; 0x562 <EEPROMWriteByte>
	EEPROMWriteByte(addr+1, (uint8_t)data);		// Write low byte to EEPROM.
 582:	6d 2f       	mov	r22, r29
 584:	81 e0       	ldi	r24, 0x01	; 1
 586:	8c 0f       	add	r24, r28
}
 588:	df 91       	pop	r29
 58a:	cf 91       	pop	r28
//   so blocking is NOT needed in this function.
void EEPROMWriteWord(uint8_t addr, uint16_t data)
{
	uint16_t dataTemp = data>>8;				// Isolate the high byte.
	EEPROMWriteByte(addr, (uint8_t)dataTemp);   // Write high byte to EEPROM.
	EEPROMWriteByte(addr+1, (uint8_t)data);		// Write low byte to EEPROM.
 58c:	ea cf       	rjmp	.-44     	; 0x562 <EEPROMWriteByte>

0000058e <EEPROMReadByte>:

// 8-bit read from EEPROM. The read needs to be atomic, so we want to disable
//   interrupts before starting it up to keep registers intact.
uint8_t EEPROMReadByte(uint8_t addr)
{
	cli();						// Disable interrupts.
 58e:	f8 94       	cli
	while (EECR & (1<<EEPE));	// Wait for any writes to finish, to avoid
 590:	e1 99       	sbic	0x1c, 1	; 28
 592:	fe cf       	rjmp	.-4      	; 0x590 <EEPROMReadByte+0x2>
								//   a resource conflict.
	EEAR = addr;				// See the datasheet for more details about
 594:	8e bb       	out	0x1e, r24	; 30
	EECR += (1<<EERE);			//  this process.
 596:	8c b3       	in	r24, 0x1c	; 28
 598:	8f 5f       	subi	r24, 0xFF	; 255
 59a:	8c bb       	out	0x1c, r24	; 28
	sei();						// Re-enable the interrupts.
 59c:	78 94       	sei
	return EEDR;				// Return the value at the address in question.
 59e:	8d b3       	in	r24, 0x1d	; 29
}
 5a0:	08 95       	ret

000005a2 <EEPROMReadWord>:
// Read a 16-bit value from EEPROM. Data is written big-endian. Note that
//   blocking while waiting for prior writes to EEPROM to complete is
//   handled in the byte read/write calls, which are called from here,
//   so blocking is NOT needed in this function.
uint16_t EEPROMReadWord(uint8_t addr)
{
 5a2:	1f 93       	push	r17
 5a4:	cf 93       	push	r28
 5a6:	df 93       	push	r29
 5a8:	18 2f       	mov	r17, r24
	uint16_t readResult;
	readResult = (uint16_t)EEPROMReadByte(addr);	// Retrieve the high byte.
 5aa:	f1 df       	rcall	.-30     	; 0x58e <EEPROMReadByte>
 5ac:	c8 2f       	mov	r28, r24
 5ae:	d0 e0       	ldi	r29, 0x00	; 0
	readResult = readResult<<8;						// Left shift the hight byte.
 5b0:	dc 2f       	mov	r29, r28
 5b2:	cc 27       	eor	r28, r28
	readResult |= (uint16_t)EEPROMReadByte(addr+1); // OR-in the low byte.
 5b4:	81 e0       	ldi	r24, 0x01	; 1
 5b6:	81 0f       	add	r24, r17
 5b8:	ea df       	rcall	.-44     	; 0x58e <EEPROMReadByte>
	return readResult;
}
 5ba:	9e 01       	movw	r18, r28
 5bc:	28 2b       	or	r18, r24
 5be:	c9 01       	movw	r24, r18
 5c0:	df 91       	pop	r29
 5c2:	cf 91       	pop	r28
 5c4:	1f 91       	pop	r17
 5c6:	08 95       	ret

000005c8 <spiXfer>:
//   unlike more advanced processors, the Tinty2313a does not support a
//   hands-off shift method. The data must be clocked out under software
//   control!
uint8_t spiXfer(uint8_t data)
{
	USIDR = data;
 5c8:	8f b9       	out	0x0f, r24	; 15
	while ((USISR & (1<<USIOIF)) == 0)
	{
		USICR = (0<<USIWM1) | (1<<USIWM0) | (1<<USICS1) | (0<<USICS0) | (1<<USICLK) | (1<<USITC);
 5ca:	8b e1       	ldi	r24, 0x1B	; 27
//   hands-off shift method. The data must be clocked out under software
//   control!
uint8_t spiXfer(uint8_t data)
{
	USIDR = data;
	while ((USISR & (1<<USIOIF)) == 0)
 5cc:	76 99       	sbic	0x0e, 6	; 14
 5ce:	02 c0       	rjmp	.+4      	; 0x5d4 <spiXfer+0xc>
	{
		USICR = (0<<USIWM1) | (1<<USIWM0) | (1<<USICS1) | (0<<USICS0) | (1<<USICLK) | (1<<USITC);
 5d0:	8d b9       	out	0x0d, r24	; 13
 5d2:	fc cf       	rjmp	.-8      	; 0x5cc <spiXfer+0x4>
	}
	USISR = (1<<USIOIF);
 5d4:	80 e4       	ldi	r24, 0x40	; 64
 5d6:	8e b9       	out	0x0e, r24	; 14
	return USIDR;
 5d8:	8f b1       	in	r24, 0x0f	; 15
 5da:	08 95       	ret

000005dc <main>:
	//   '1' to the appropriate bit in a DDRx register will render that pin an
	//   output.
	
	// Port A- both pins are unused, so we'll make them both outputs and drive them
	//   low to save power.
	DDRA = (1<<PA1) | (1<<PA0);
 5dc:	83 e0       	ldi	r24, 0x03	; 3
 5de:	8a bb       	out	0x1a, r24	; 26
	// Port B- PB0-3 are unused; make them outputs and tie them low. PB4 is !CS
	//   for the ADXL362, so it should be an output. PB5 is MISO from the ADXL362, so
	//   leave it an input. PB6 is MOSI to ADXL362, and PB7 is SCK, so they should be
	//   outputs.
	DDRB = (1<<PB7) | (1<<PB6) | (1<<PB4) | (1<<PB3) | (1<<PB2)| (1<<PB1) | (1<<PB0);
 5e0:	8f ed       	ldi	r24, 0xDF	; 223
 5e2:	87 bb       	out	0x17, r24	; 23
	// Port D- PD0 is the serial receive input. PD1 is serial transmit output. PD2 is
	//   is an external interrupt used to wake the processor on serial activity. PD3
	//   is the interrupt from the ADXL362, used to wake the device on detected
	//   motion. PD4 is the MOSFET turn-on signal, so should be an output. PD5 and
	//   PD6 are unused; make them outputs and tie them low. PD7 doesn't exist.
	DDRD = (1<<PD6) | (1<<PD5) | (1<<PD4) | (1<<PD1);
 5e4:	82 e7       	ldi	r24, 0x72	; 114
 5e6:	81 bb       	out	0x11, r24	; 17
	
	// Now let's configure some initial IO states
	
	// Port A- both set low to reduce current consumption
	PORTA = (0<<PA1) | (0<<PA0);
 5e8:	1b ba       	out	0x1b, r1	; 27
	// Port B- PB0-3 should be low for power consumption; PB4 is !CS, so bring it
	//   high to keep the ADXL362 non-selected. Others are don't care.
	PORTB = (1<<PB4) | (0<<PB3) | (0<<PB2) | (0<<PB1) | (0<<PB0);
 5ea:	80 e1       	ldi	r24, 0x10	; 16
 5ec:	88 bb       	out	0x18, r24	; 24
	// Port C doesn't exist
	// Port D- PD5 and PD6 should be tied low; others are (for now) don't care.
	//   Also, PD2/PD0 should be made high to enable pullup resistor for when no
	//   serial connection is present.
	PORTD = (1<<PD6) | (1<<PD5) | (1<<PD2) | (1<<PD0);
 5ee:	85 e6       	ldi	r24, 0x65	; 101
 5f0:	82 bb       	out	0x12, r24	; 18
	//   INT0 will wiggle when a serial connection occurs. INT1 will wiggle when
	//   the ADXL362 detects motion and wakes up.
	
	// MCUCR- Bits 0:3 control the interrupt event we want to be sensitive to.
	//   We'll set it so a low level is what each pin is looking for.
	MCUCR = (0<<ISC11) | (0<<ISC10) | (0<<ISC01) | (0<<ISC00);
 5f2:	15 be       	out	0x35, r1	; 53
	// GIMSK- These are mask bits for the pin change interrupts. Writing a '1'
	//   enables the appropriate interrupt.
	GIMSK = (0<<INT1) | (0<<INT0);
 5f4:	1b be       	out	0x3b, r1	; 59
	
	// UISCR- USWM1:0 are mode select pins; 01 is three-wire mode.
	//   USICS1:0 are clock source select pins; 10 is software control.
	//   USICLK puts the 4-bit data counter under software control.
	//   Strobing USITC toggles the 4-bit clock signal.
	USICR = (0<<USIWM1) | (1<<USIWM0) | (1<<USICS1) | (0<<USICS0) | (1<<USICLK);
 5f6:	8a e1       	ldi	r24, 0x1A	; 26
 5f8:	8d b9       	out	0x0d, r24	; 13
	// USISR- Writing '1' to USIOIF will clear the 4-bit counter overflow
	//   flag and ready it for the next transfer. Implicit here is a write
	//   of zeroes to bits 3:0 of this register, which also clears the 4-bit
	//   counter.
	USISR = (1<<USIOIF);
 5fa:	80 e4       	ldi	r24, 0x40	; 64
 5fc:	8e b9       	out	0x0e, r24	; 14
	//   set the mode to 9600 baud, 8-N-1. Pretty standard, really.

	// For 9600 baud, at 1.000MHz (which is our clock speed, since we're
	//   using the internal oscillator clocked down), UBRR should be set to
	//   12, and the U2X bit of UCSRA should be set to '1'.
	UBRRH = 0;
 5fe:	12 b8       	out	0x02, r1	; 2
	UBRRL = 12;
 600:	8c e0       	ldi	r24, 0x0C	; 12
 602:	89 b9       	out	0x09, r24	; 9
	UCSRA = (1<<U2X);
 604:	82 e0       	ldi	r24, 0x02	; 2
 606:	8b b9       	out	0x0b, r24	; 11
	// UCSRB- RXEN and TXEN enable the transmit and receive circuitry.
	//   UCSZ2 is a frame size bit; when set to 0 (as here), the size is
	//   determined by UCSZ1:0 in UCSRC. RXCIE is the receive interrupt
	//   enable bit; we want that interrupt for handling incoming settings
	//   changes while the part is awake.
	UCSRB = (1<<RXCIE) | (1<<RXEN) | (1<<TXEN);
 608:	88 e9       	ldi	r24, 0x98	; 152
 60a:	8a b9       	out	0x0a, r24	; 10
	// UCSRC- Setting UCSZ1:0 to '1' gives us an 8-bit frame size. There
	//   are provisions in this register for synchronous mode, parity,
	//   and stop-bit count, but we'll ignore them.
	UCSRC = (1<<UCSZ1) | (1<<UCSZ0);
 60c:	86 e0       	ldi	r24, 0x06	; 6
 60e:	83 b9       	out	0x03, r24	; 3
	// set_sleep_mode() is a nice little macro from the sleep library which
	//   sets the stage nicely for sleep; after this, all you need to do is
	//   call sleep_mode() to put the processor to sleep. Power Down mode is
	//   the lowest possible sleep power state; all clocks are stopped and
	//   only an external interrupt can wake the processor.
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 610:	85 b7       	in	r24, 0x35	; 53
 612:	80 65       	ori	r24, 0x50	; 80
 614:	85 bf       	out	0x35, r24	; 53
	
	// Check to make sure the EEPROM has been configured for first use by
	//   looking at the "key" location. If not, configure it.
	if (EEPROMReadByte((uint8_t)KEY_ADDR) != KEY) EEPROMConfig();
 616:	8f e7       	ldi	r24, 0x7F	; 127
 618:	ba df       	rcall	.-140    	; 0x58e <EEPROMReadByte>
 61a:	8b 37       	cpi	r24, 0x7B	; 123
 61c:	09 f0       	breq	.+2      	; 0x620 <main+0x44>
 61e:	35 dd       	rcall	.-1430   	; 0x8a <EEPROMConfig>
	
	// EEPROMRetrieve() pulls the various operational parameters out of
	//   EEPROM and puts them in SRAM.
	EEPROMRetrieve();
 620:	1e dd       	rcall	.-1476   	; 0x5e <EEPROMRetrieve>
	
	// Configure the ADXL362 with the info we just pulled from EEPROM.
	ADXLConfig();
 622:	78 df       	rcall	.-272    	; 0x514 <ADXLConfig>
	//   stay awake long enough for the user to input some parameters.
	//   Timer1 is a 16-bit counter; I'm going to set it up so that it ticks
	//   over every 10 seconds when the device is awake, and when it ticks,
	//   the device drops back into sleep.
	// TCCR1B- 101 in CS1 bits divides the clock by 1024; ~one count per ms.
	TCCR1B = (1<<CS12) | (0<<CS11) | (1<<CS10);
 624:	85 e0       	ldi	r24, 0x05	; 5
 626:	8e bd       	out	0x2e, r24	; 46
	// TCNT1- When this hits 65,536, an overflow interrupt occurs. By
	//   "priming" it, we reduce the time until an interrupt occurs.
	//   The if/else is to prevent the user accidentally
	//   setting it so low that the part goes back to sleep before it can be
	//   reprogrammed by the user through the command line.
	TCNT1 = t1Offset;
 628:	80 91 71 00 	lds	r24, 0x0071
 62c:	90 91 72 00 	lds	r25, 0x0072
 630:	9d bd       	out	0x2d, r25	; 45
 632:	8c bd       	out	0x2c, r24	; 44
	// TIMSK- Set TOIE1 to enable Timer1 overflow interrupt
	TIMSK = (1<<TOIE1);
 634:	80 e8       	ldi	r24, 0x80	; 128
 636:	89 bf       	out	0x39, r24	; 57
	
	// loadOn() is a simple function that turns on the load. We'll turn it on
	//   now and leave it on until sleep.
	loadOn();
 638:	94 9a       	sbi	0x12, 4	; 18
	// sei() is a macro that basically executes the single instruction
	//   global interrupt enable function. Up until now, interrupt sources
	//   are ignored. We will turn this on and leave it on, unless we need
	//   to perform some sensitive tasks which require interrupts disabled
	//   for a time.
	sei();
 63a:	78 94       	sei
	
	// Okay, now we can move forward with our main application code. This loop
	//   will just run over and over forever, waiting for signals from interrupts
	//   to tell it what to do.
	printMenu();
 63c:	41 dd       	rcall	.-1406   	; 0xc0 <printMenu>
		//   true.
		if (sleepyTime == TRUE)
		{
			serialWrite("z");			// Let the user know sleep mode is coming.
			ADXLConfig();
			GIMSK = (1<<INT0) |(1<<INT1);// Enable external interrupts to wake the
 63e:	c0 ec       	ldi	r28, 0xC0	; 192
	while(1)
	{
		// The main functionality is to go to sleep when there's been no activity
		//   for some time; if Timer1 manages to overflow, it will set sleepyTime
		//   true.
		if (sleepyTime == TRUE)
 640:	80 91 6d 00 	lds	r24, 0x006D
 644:	81 30       	cpi	r24, 0x01	; 1
 646:	89 f4       	brne	.+34     	; 0x66a <main+0x8e>
		{
			serialWrite("z");			// Let the user know sleep mode is coming.
 648:	81 e6       	ldi	r24, 0x61	; 97
 64a:	90 e0       	ldi	r25, 0x00	; 0
 64c:	93 de       	rcall	.-730    	; 0x374 <serialWrite>
			ADXLConfig();
 64e:	62 df       	rcall	.-316    	; 0x514 <ADXLConfig>
			GIMSK = (1<<INT0) |(1<<INT1);// Enable external interrupts to wake the
 650:	cb bf       	out	0x3b, r28	; 59
										//   processor up; INT0 is incoming serial
										//   data, INT1 is accelerometer interrupt
			loadOff();					// Turn off the load for sleepy time.
 652:	82 b3       	in	r24, 0x12	; 18
 654:	12 ba       	out	0x12, r1	; 18
			sleep_mode();				// Go to sleep until awoken by an interrupt.
 656:	85 b7       	in	r24, 0x35	; 53
 658:	80 62       	ori	r24, 0x20	; 32
 65a:	85 bf       	out	0x35, r24	; 53
 65c:	88 95       	sleep
 65e:	85 b7       	in	r24, 0x35	; 53
 660:	8f 7d       	andi	r24, 0xDF	; 223
 662:	85 bf       	out	0x35, r24	; 53
			EEPROMRetrieve();			// Retrieve EEPROM values, mostly to print
 664:	fc dc       	rcall	.-1544   	; 0x5e <EEPROMRetrieve>
										//   them out to the user, if the wake-up
										//   was due to serial data arriving.
			printMenu();
 666:	2c dd       	rcall	.-1448   	; 0xc0 <printMenu>
			loadOn();					// Turn the load back on.
 668:	94 9a       	sbi	0x12, 4	; 18
		}
		// Any data arriving over the serial port will trigger a serial receive
		//   interrupt. If that data is non-null, serialParse() will be called to
		//   deal with it.
		if (serialRxData != 0) serialParse();
 66a:	80 91 6c 00 	lds	r24, 0x006C
 66e:	88 23       	and	r24, r24
 670:	39 f3       	breq	.-50     	; 0x640 <main+0x64>
 672:	2c dd       	rcall	.-1448   	; 0xcc <serialParse>
 674:	e5 cf       	rjmp	.-54     	; 0x640 <main+0x64>

00000676 <__mulhi3>:
 676:	00 24       	eor	r0, r0
 678:	55 27       	eor	r21, r21
 67a:	04 c0       	rjmp	.+8      	; 0x684 <__mulhi3+0xe>
 67c:	08 0e       	add	r0, r24
 67e:	59 1f       	adc	r21, r25
 680:	88 0f       	add	r24, r24
 682:	99 1f       	adc	r25, r25
 684:	00 97       	sbiw	r24, 0x00	; 0
 686:	29 f0       	breq	.+10     	; 0x692 <__mulhi3+0x1c>
 688:	76 95       	lsr	r23
 68a:	67 95       	ror	r22
 68c:	b8 f3       	brcs	.-18     	; 0x67c <__mulhi3+0x6>
 68e:	71 05       	cpc	r23, r1
 690:	b9 f7       	brne	.-18     	; 0x680 <__mulhi3+0xa>
 692:	80 2d       	mov	r24, r0
 694:	95 2f       	mov	r25, r21
 696:	08 95       	ret

00000698 <__udivmodhi4>:
 698:	aa 1b       	sub	r26, r26
 69a:	bb 1b       	sub	r27, r27
 69c:	51 e1       	ldi	r21, 0x11	; 17
 69e:	07 c0       	rjmp	.+14     	; 0x6ae <__udivmodhi4_ep>

000006a0 <__udivmodhi4_loop>:
 6a0:	aa 1f       	adc	r26, r26
 6a2:	bb 1f       	adc	r27, r27
 6a4:	a6 17       	cp	r26, r22
 6a6:	b7 07       	cpc	r27, r23
 6a8:	10 f0       	brcs	.+4      	; 0x6ae <__udivmodhi4_ep>
 6aa:	a6 1b       	sub	r26, r22
 6ac:	b7 0b       	sbc	r27, r23

000006ae <__udivmodhi4_ep>:
 6ae:	88 1f       	adc	r24, r24
 6b0:	99 1f       	adc	r25, r25
 6b2:	5a 95       	dec	r21
 6b4:	a9 f7       	brne	.-22     	; 0x6a0 <__udivmodhi4_loop>
 6b6:	80 95       	com	r24
 6b8:	90 95       	com	r25
 6ba:	bc 01       	movw	r22, r24
 6bc:	cd 01       	movw	r24, r26
 6be:	08 95       	ret

000006c0 <_exit>:
 6c0:	f8 94       	cli

000006c2 <__stop_program>:
 6c2:	ff cf       	rjmp	.-2      	; 0x6c2 <__stop_program>
