   1               		.file	"interrupts.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.text
   7               	.Ltext0:
   8               		.cfi_sections	.debug_frame
   9               	.global	__vector_5
  11               	__vector_5:
  12               	.LFB0:
  13               		.file 1 "interrupts.c"
   1:interrupts.c  **** /******************************************************************************
   2:interrupts.c  **** Created 26 Nov 2012 by Mike Hord at SparkFun Electronics.
   3:interrupts.c  **** Wake-on-Shake hardware and firmware are released under the Creative Commons 
   4:interrupts.c  **** Share Alike v3.0 license:
   5:interrupts.c  **** 	http://creativecommons.org/licenses/by-sa/3.0/
   6:interrupts.c  **** Feel free to use, distribute, and sell variants of Wake-on-Shake. All we ask 
   7:interrupts.c  **** is that you include attribution of 'Based on Wake-on-Shake by SparkFun'.
   8:interrupts.c  **** 
   9:interrupts.c  **** interrupts.cpp
  10:interrupts.c  **** Interrupt service routine code. ISR length is minimized as much as possible;
  11:interrupts.c  **** the application in question doesn't really have hard real-time deadlines, so
  12:interrupts.c  **** we're free to be kind of lax with our response times.
  13:interrupts.c  **** ******************************************************************************/
  14:interrupts.c  **** 
  15:interrupts.c  **** #include <avr/io.h>
  16:interrupts.c  **** #include <avr/interrupt.h>
  17:interrupts.c  **** #include "interrupts.h"
  18:interrupts.c  **** #include "wake-on-shake.h"
  19:interrupts.c  **** #include "serial.h"
  20:interrupts.c  **** #include "eeprom.h"
  21:interrupts.c  **** 
  22:interrupts.c  **** extern uint16_t				t1Offset;		// See Wake-on-Shake.cpp
  23:interrupts.c  **** extern volatile uint8_t		sleepyTime;		// See Wake-on-Shake.cpp
  24:interrupts.c  **** extern volatile uint8_t     serialRxData;	// See Wake-on-Shake.cpp
  25:interrupts.c  **** 
  26:interrupts.c  **** // Timer1 overflow ISR- this is the means by which the device goes to sleep
  27:interrupts.c  **** //   after it's been on for a certain time. Timer1 has been set up to tick
  28:interrupts.c  **** //   on clock/1024, which is ~1ms ticks; it's a 16-bit overflow, so left to
  29:interrupts.c  **** //   it's own devices, it will overflow every 65536 ticks, or after a bit
  30:interrupts.c  **** //   more than a minute. To shorten that time, we prime TCNT1
  31:interrupts.c  **** ISR(TIMER1_OVF_vect)
  32:interrupts.c  **** {
  14               		.loc 1 32 1 view -0
  15               		.cfi_startproc
  16 0000 8F93      		__gcc_isr 1
  17               	/* prologue: Signal */
  18               	/* frame size = 0 */
  19               	/* stack size = 0...4 */
  20               	.L__stack_usage = 0 + __gcc_isr.n_pushed
  33:interrupts.c  **** 	sleepyTime = TRUE;
  21               		.loc 1 33 2 view .LVU1
  22               		.loc 1 33 13 is_stmt 0 view .LVU2
  23 0002 81E0      		ldi r24,lo8(1)
  24 0004 8093 0000 		sts sleepyTime,r24
  25               	/* epilogue start */
  34:interrupts.c  **** }
  26               		.loc 1 34 1 view .LVU3
  27 0008 8F91      		__gcc_isr 2
  28 000a 1895      		reti
  29               		__gcc_isr 0,r24
  30               		.cfi_endproc
  31               	.LFE0:
  33               	.global	__vector_1
  35               	__vector_1:
  36               	.LFB1:
  35:interrupts.c  **** 
  36:interrupts.c  **** // INT0 ISR- This is one way the processor can wake from sleep. INT0 is tied
  37:interrupts.c  **** //   externally to the RX pin, so traffic on the serial receive line will
  38:interrupts.c  **** //   wake up the part when it is asleep. Note that the receive interrupt
  39:interrupts.c  **** //   can't wake the processor from sleep- don't try!
  40:interrupts.c  **** ISR(INT0_vect)
  41:interrupts.c  **** {
  37               		.loc 1 41 1 is_stmt 1 view -0
  38               		.cfi_startproc
  39 000c 1F92 1FB6 		__gcc_isr 1
  39      1F92 1124 
  39      8F93 
  40 0016 9F93      		push r25
  41               	.LCFI0:
  42               		.cfi_def_cfa_offset 3
  43               		.cfi_offset 25, -2
  44               	/* prologue: Signal */
  45               	/* frame size = 0 */
  46               	/* stack size = 1...5 */
  47               	.L__stack_usage = 1 + __gcc_isr.n_pushed
  42:interrupts.c  **** 	TCNT1 = t1Offset;				// Reset our counter for on-time.
  48               		.loc 1 42 2 view .LVU5
  49               		.loc 1 42 8 is_stmt 0 view .LVU6
  50 0018 8091 0000 		lds r24,t1Offset
  51 001c 9091 0000 		lds r25,t1Offset+1
  52 0020 9DBD      		out 0x2c+1,r25
  53 0022 8CBD      		out 0x2c,r24
  43:interrupts.c  **** 	sleepyTime = FALSE;				// Indicate wakefulness to main loop.
  54               		.loc 1 43 2 is_stmt 1 view .LVU7
  55               		.loc 1 43 13 is_stmt 0 view .LVU8
  56 0024 1092 0000 		sts sleepyTime,__zero_reg__
  44:interrupts.c  **** 	GIMSK = (0<<INT0)|(0<<INT1);	// Disable INT pins while we're awake.
  57               		.loc 1 44 2 is_stmt 1 view .LVU9
  58               		.loc 1 44 8 is_stmt 0 view .LVU10
  59 0028 1BBE      		out 0x3b,__zero_reg__
  60               	/* epilogue start */
  45:interrupts.c  **** 									//  This is important b/c the INT pins
  46:interrupts.c  **** 									//  cause an interrupt on LOW rather
  47:interrupts.c  **** 									//  than on an edge, so the interrupt
  48:interrupts.c  **** 									//  will continue to fire as long as
  49:interrupts.c  **** 									//  the pin is low unless it is disabled.
  50:interrupts.c  **** }
  61               		.loc 1 50 1 view .LVU11
  62 002a 9F91      		pop r25
  63 002c 8F91 1F90 		__gcc_isr 2
  63      1FBE 1F90 
  64 0034 1895      		reti
  65               		__gcc_isr 0,r24
  66               		.cfi_endproc
  67               	.LFE1:
  69               	.global	__vector_2
  71               	__vector_2:
  72               	.LFB5:
  73               		.cfi_startproc
  74 0036 1F92      		push r1
  75               	.LCFI1:
  76               		.cfi_def_cfa_offset 3
  77               		.cfi_offset 1, -2
  78 0038 0F92      		push r0
  79               	.LCFI2:
  80               		.cfi_def_cfa_offset 4
  81               		.cfi_offset 0, -3
  82 003a 0FB6      		in r0,__SREG__
  83 003c 0F92      		push r0
  84 003e 1124      		clr __zero_reg__
  85 0040 2F93      		push r18
  86               	.LCFI3:
  87               		.cfi_def_cfa_offset 5
  88               		.cfi_offset 18, -4
  89 0042 3F93      		push r19
  90               	.LCFI4:
  91               		.cfi_def_cfa_offset 6
  92               		.cfi_offset 19, -5
  93 0044 4F93      		push r20
  94               	.LCFI5:
  95               		.cfi_def_cfa_offset 7
  96               		.cfi_offset 20, -6
  97 0046 5F93      		push r21
  98               	.LCFI6:
  99               		.cfi_def_cfa_offset 8
 100               		.cfi_offset 21, -7
 101 0048 6F93      		push r22
 102               	.LCFI7:
 103               		.cfi_def_cfa_offset 9
 104               		.cfi_offset 22, -8
 105 004a 7F93      		push r23
 106               	.LCFI8:
 107               		.cfi_def_cfa_offset 10
 108               		.cfi_offset 23, -9
 109 004c 8F93      		push r24
 110               	.LCFI9:
 111               		.cfi_def_cfa_offset 11
 112               		.cfi_offset 24, -10
 113 004e 9F93      		push r25
 114               	.LCFI10:
 115               		.cfi_def_cfa_offset 12
 116               		.cfi_offset 25, -11
 117 0050 AF93      		push r26
 118               	.LCFI11:
 119               		.cfi_def_cfa_offset 13
 120               		.cfi_offset 26, -12
 121 0052 BF93      		push r27
 122               	.LCFI12:
 123               		.cfi_def_cfa_offset 14
 124               		.cfi_offset 27, -13
 125 0054 EF93      		push r30
 126               	.LCFI13:
 127               		.cfi_def_cfa_offset 15
 128               		.cfi_offset 30, -14
 129 0056 FF93      		push r31
 130               	.LCFI14:
 131               		.cfi_def_cfa_offset 16
 132               		.cfi_offset 31, -15
 133               	/* prologue: Signal */
 134               	/* frame size = 0 */
 135               	/* stack size = 15 */
 136               	.L__stack_usage = 15
 137 0058 00D0      		rcall __vector_1
 138               	/* epilogue start */
 139 005a FF91      		pop r31
 140 005c EF91      		pop r30
 141 005e BF91      		pop r27
 142 0060 AF91      		pop r26
 143 0062 9F91      		pop r25
 144 0064 8F91      		pop r24
 145 0066 7F91      		pop r23
 146 0068 6F91      		pop r22
 147 006a 5F91      		pop r21
 148 006c 4F91      		pop r20
 149 006e 3F91      		pop r19
 150 0070 2F91      		pop r18
 151 0072 0F90      		pop r0
 152 0074 0FBE      		out __SREG__,r0
 153 0076 0F90      		pop r0
 154 0078 1F90      		pop r1
 155 007a 1895      		reti
 156               		.cfi_endproc
 157               	.LFE5:
 159               	.global	__vector_7
 161               	__vector_7:
 162               	.LFB3:
  51:interrupts.c  **** 
  52:interrupts.c  **** // INT1 ISR- this is the primary way the processor wakes from sleep. INT1 is
  53:interrupts.c  **** //   tied to the interrupt output pin on the ADXL362, which goes low when
  54:interrupts.c  **** //   motion is detected.
  55:interrupts.c  **** ISR(INT1_vect)
  56:interrupts.c  **** {
  57:interrupts.c  **** 	TCNT1 = t1Offset;				// See INT0 ISR for details.
  58:interrupts.c  **** 	sleepyTime = FALSE;
  59:interrupts.c  **** 	GIMSK = (0<<INT0)|(0<<INT1); 
  60:interrupts.c  **** }
  61:interrupts.c  **** 
  62:interrupts.c  **** // USART_RX ISR- gets called when the processor is awake and a complete
  63:interrupts.c  **** //   byte (including stop bit) has been received by the USART. This
  64:interrupts.c  **** //   interrupt CANNOT be used to wake the processor, so don't try it.
  65:interrupts.c  **** ISR(USART_RX_vect)
  66:interrupts.c  **** {
 163               		.loc 1 66 1 is_stmt 1 view -0
 164               		.cfi_startproc
 165               		.loc 1 66 1 is_stmt 0 view .LVU13
 166 007c 8F93      		__gcc_isr 1
 167 007e 9F93      		push r25
 168               	.LCFI15:
 169               		.cfi_def_cfa_offset 3
 170               		.cfi_offset 25, -2
 171               	/* prologue: Signal */
 172               	/* frame size = 0 */
 173               	/* stack size = 1...5 */
 174               	.L__stack_usage = 1 + __gcc_isr.n_pushed
  67:interrupts.c  **** 	TCNT1 = t1Offset;	// Reset the wakefulness timer, so the processor
 175               		.loc 1 67 2 is_stmt 1 view .LVU14
 176               		.loc 1 67 8 is_stmt 0 view .LVU15
 177 0080 8091 0000 		lds r24,t1Offset
 178 0084 9091 0000 		lds r25,t1Offset+1
 179 0088 9DBD      		out 0x2c+1,r25
 180 008a 8CBD      		out 0x2c,r24
  68:interrupts.c  **** 						//   doesn't go to sleep while the user is
  69:interrupts.c  **** 						//   interacting with it.
  70:interrupts.c  **** 	serialRxData = UDR; // Pass the data back to the main loop for parsing.
 181               		.loc 1 70 2 is_stmt 1 view .LVU16
 182               		.loc 1 70 17 is_stmt 0 view .LVU17
 183 008c 8CB1      		in r24,0xc
 184               		.loc 1 70 15 view .LVU18
 185 008e 8093 0000 		sts serialRxData,r24
 186               	/* epilogue start */
  71:interrupts.c  **** }
 187               		.loc 1 71 1 view .LVU19
 188 0092 9F91      		pop r25
 189 0094 8F91      		__gcc_isr 2
 190 0096 1895      		reti
 191               		__gcc_isr 0,r24
 192               		.cfi_endproc
 193               	.LFE3:
 195               	.Letext0:
 196               		.file 2 "/usr/local/Cellar/avr-gcc/9.2.0/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 interrupts.c
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:2      *ABS*:000000000000003d __SP_L__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:3      *ABS*:000000000000003f __SREG__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:4      *ABS*:0000000000000000 __tmp_reg__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:5      *ABS*:0000000000000001 __zero_reg__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:11     .text:0000000000000000 __vector_5
                            *ABS*:0000000000000001 __gcc_isr.n_pushed.001
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:35     .text:000000000000000c __vector_1
                            *ABS*:0000000000000003 __gcc_isr.n_pushed.002
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:71     .text:0000000000000036 __vector_2
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cc9J3SmD.s:161    .text:000000000000007c __vector_7
                            *ABS*:0000000000000001 __gcc_isr.n_pushed.003

UNDEFINED SYMBOLS
sleepyTime
t1Offset
serialRxData
