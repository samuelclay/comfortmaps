   1               		.file	"interrupts.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.text
   7               	.Ltext0:
   8               		.cfi_sections	.debug_frame
   9               	.global	__vector_5
  11               	__vector_5:
  12               	.LFB0:
  13               		.file 1 "interrupts.c"
   1:interrupts.c  **** /******************************************************************************
   2:interrupts.c  **** Created 26 Nov 2012 by Mike Hord at SparkFun Electronics.
   3:interrupts.c  **** Wake-on-Shake hardware and firmware are released under the Creative Commons 
   4:interrupts.c  **** Share Alike v3.0 license:
   5:interrupts.c  **** 	http://creativecommons.org/licenses/by-sa/3.0/
   6:interrupts.c  **** Feel free to use, distribute, and sell variants of Wake-on-Shake. All we ask 
   7:interrupts.c  **** is that you include attribution of 'Based on Wake-on-Shake by SparkFun'.
   8:interrupts.c  **** 
   9:interrupts.c  **** interrupts.cpp
  10:interrupts.c  **** Interrupt service routine code. ISR length is minimized as much as possible;
  11:interrupts.c  **** the application in question doesn't really have hard real-time deadlines, so
  12:interrupts.c  **** we're free to be kind of lax with our response times.
  13:interrupts.c  **** ******************************************************************************/
  14:interrupts.c  **** 
  15:interrupts.c  **** #include <avr/io.h>
  16:interrupts.c  **** #include <avr/interrupt.h>
  17:interrupts.c  **** #include "interrupts.h"
  18:interrupts.c  **** #include "wake-on-shake.h"
  19:interrupts.c  **** #include "serial.h"
  20:interrupts.c  **** #include "eeprom.h"
  21:interrupts.c  **** 
  22:interrupts.c  **** extern uint16_t				t1Offset;		// See Wake-on-Shake.cpp
  23:interrupts.c  **** extern volatile uint8_t		sleepyTime;		// See Wake-on-Shake.cpp
  24:interrupts.c  **** extern volatile uint8_t     serialRxData;	// See Wake-on-Shake.cpp
  25:interrupts.c  **** 
  26:interrupts.c  **** // Timer1 overflow ISR- this is the means by which the device goes to sleep
  27:interrupts.c  **** //   after it's been on for a certain time. Timer1 has been set up to tick
  28:interrupts.c  **** //   on clock/1024, which is ~1ms ticks; it's a 16-bit overflow, so left to
  29:interrupts.c  **** //   it's own devices, it will overflow every 65536 ticks, or after a bit
  30:interrupts.c  **** //   more than a minute. To shorten that time, we prime TCNT1
  31:interrupts.c  **** ISR(TIMER1_OVF_vect)
  32:interrupts.c  **** {
  14               		.loc 1 32 0
  15               		.cfi_startproc
  16 0000 1F92      		push r1
  17               	.LCFI0:
  18               		.cfi_def_cfa_offset 3
  19               		.cfi_offset 1, -2
  20 0002 0F92      		push r0
  21               	.LCFI1:
  22               		.cfi_def_cfa_offset 4
  23               		.cfi_offset 0, -3
  24 0004 0FB6      		in r0,__SREG__
  25 0006 0F92      		push r0
  26 0008 1124      		clr __zero_reg__
  27 000a 8F93      		push r24
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 24, -4
  31               	/* prologue: Signal */
  32               	/* frame size = 0 */
  33               	/* stack size = 4 */
  34               	.L__stack_usage = 4
  33:interrupts.c  **** 	sleepyTime = TRUE;
  35               		.loc 1 33 0
  36 000c 81E0      		ldi r24,lo8(1)
  37 000e 8093 0000 		sts sleepyTime,r24
  38               	/* epilogue start */
  34:interrupts.c  **** }
  39               		.loc 1 34 0
  40 0012 8F91      		pop r24
  41 0014 0F90      		pop r0
  42 0016 0FBE      		out __SREG__,r0
  43 0018 0F90      		pop r0
  44 001a 1F90      		pop r1
  45 001c 1895      		reti
  46               		.cfi_endproc
  47               	.LFE0:
  49               	.global	__vector_1
  51               	__vector_1:
  52               	.LFB1:
  35:interrupts.c  **** 
  36:interrupts.c  **** // INT0 ISR- This is one way the processor can wake from sleep. INT0 is tied
  37:interrupts.c  **** //   externally to the RX pin, so traffic on the serial receive line will
  38:interrupts.c  **** //   wake up the part when it is asleep. Note that the receive interrupt
  39:interrupts.c  **** //   can't wake the processor from sleep- don't try!
  40:interrupts.c  **** ISR(INT0_vect)
  41:interrupts.c  **** {
  53               		.loc 1 41 0
  54               		.cfi_startproc
  55 001e 1F92      		push r1
  56               	.LCFI3:
  57               		.cfi_def_cfa_offset 3
  58               		.cfi_offset 1, -2
  59 0020 0F92      		push r0
  60               	.LCFI4:
  61               		.cfi_def_cfa_offset 4
  62               		.cfi_offset 0, -3
  63 0022 0FB6      		in r0,__SREG__
  64 0024 0F92      		push r0
  65 0026 1124      		clr __zero_reg__
  66 0028 8F93      		push r24
  67               	.LCFI5:
  68               		.cfi_def_cfa_offset 5
  69               		.cfi_offset 24, -4
  70 002a 9F93      		push r25
  71               	.LCFI6:
  72               		.cfi_def_cfa_offset 6
  73               		.cfi_offset 25, -5
  74               	/* prologue: Signal */
  75               	/* frame size = 0 */
  76               	/* stack size = 5 */
  77               	.L__stack_usage = 5
  42:interrupts.c  **** 	TCNT1 = t1Offset;				// Reset our counter for on-time.
  78               		.loc 1 42 0
  79 002c 8091 0000 		lds r24,t1Offset
  80 0030 9091 0000 		lds r25,t1Offset+1
  81 0034 9DBD      		out 0x2c+1,r25
  82 0036 8CBD      		out 0x2c,r24
  43:interrupts.c  **** 	sleepyTime = FALSE;				// Indicate wakefulness to main loop.
  83               		.loc 1 43 0
  84 0038 1092 0000 		sts sleepyTime,__zero_reg__
  44:interrupts.c  **** 	GIMSK = (0<<INT0)|(0<<INT1);	// Disable INT pins while we're awake.
  85               		.loc 1 44 0
  86 003c 1BBE      		out 0x3b,__zero_reg__
  87               	/* epilogue start */
  45:interrupts.c  **** 									//  This is important b/c the INT pins
  46:interrupts.c  **** 									//  cause an interrupt on LOW rather
  47:interrupts.c  **** 									//  than on an edge, so the interrupt
  48:interrupts.c  **** 									//  will continue to fire as long as
  49:interrupts.c  **** 									//  the pin is low unless it is disabled.
  50:interrupts.c  **** }
  88               		.loc 1 50 0
  89 003e 9F91      		pop r25
  90 0040 8F91      		pop r24
  91 0042 0F90      		pop r0
  92 0044 0FBE      		out __SREG__,r0
  93 0046 0F90      		pop r0
  94 0048 1F90      		pop r1
  95 004a 1895      		reti
  96               		.cfi_endproc
  97               	.LFE1:
  99               	.global	__vector_2
 101               	__vector_2:
 102               	.LFB2:
  51:interrupts.c  **** 
  52:interrupts.c  **** // INT1 ISR- this is the primary way the processor wakes from sleep. INT1 is
  53:interrupts.c  **** //   tied to the interrupt output pin on the ADXL362, which goes low when
  54:interrupts.c  **** //   motion is detected.
  55:interrupts.c  **** ISR(INT1_vect)
  56:interrupts.c  **** {
 103               		.loc 1 56 0
 104               		.cfi_startproc
 105 004c 1F92      		push r1
 106               	.LCFI7:
 107               		.cfi_def_cfa_offset 3
 108               		.cfi_offset 1, -2
 109 004e 0F92      		push r0
 110               	.LCFI8:
 111               		.cfi_def_cfa_offset 4
 112               		.cfi_offset 0, -3
 113 0050 0FB6      		in r0,__SREG__
 114 0052 0F92      		push r0
 115 0054 1124      		clr __zero_reg__
 116 0056 8F93      		push r24
 117               	.LCFI9:
 118               		.cfi_def_cfa_offset 5
 119               		.cfi_offset 24, -4
 120 0058 9F93      		push r25
 121               	.LCFI10:
 122               		.cfi_def_cfa_offset 6
 123               		.cfi_offset 25, -5
 124               	/* prologue: Signal */
 125               	/* frame size = 0 */
 126               	/* stack size = 5 */
 127               	.L__stack_usage = 5
  57:interrupts.c  **** 	TCNT1 = t1Offset;				// See INT0 ISR for details.
 128               		.loc 1 57 0
 129 005a 8091 0000 		lds r24,t1Offset
 130 005e 9091 0000 		lds r25,t1Offset+1
 131 0062 9DBD      		out 0x2c+1,r25
 132 0064 8CBD      		out 0x2c,r24
  58:interrupts.c  **** 	sleepyTime = FALSE;
 133               		.loc 1 58 0
 134 0066 1092 0000 		sts sleepyTime,__zero_reg__
  59:interrupts.c  **** 	GIMSK = (0<<INT0)|(0<<INT1); 
 135               		.loc 1 59 0
 136 006a 1BBE      		out 0x3b,__zero_reg__
 137               	/* epilogue start */
  60:interrupts.c  **** }
 138               		.loc 1 60 0
 139 006c 9F91      		pop r25
 140 006e 8F91      		pop r24
 141 0070 0F90      		pop r0
 142 0072 0FBE      		out __SREG__,r0
 143 0074 0F90      		pop r0
 144 0076 1F90      		pop r1
 145 0078 1895      		reti
 146               		.cfi_endproc
 147               	.LFE2:
 149               	.global	USART_RX_vect
 151               	USART_RX_vect:
 152               	.LFB3:
  61:interrupts.c  **** 
  62:interrupts.c  **** // USART_RX ISR- gets called when the processor is awake and a complete
  63:interrupts.c  **** //   byte (including stop bit) has been received by the USART. This
  64:interrupts.c  **** //   interrupt CANNOT be used to wake the processor, so don't try it.
  65:interrupts.c  **** ISR(USART_RX_vect)
  66:interrupts.c  **** {
 153               		.loc 1 66 0
 154               		.cfi_startproc
 155 007a 1F92      		push r1
 156               	.LCFI11:
 157               		.cfi_def_cfa_offset 3
 158               		.cfi_offset 1, -2
 159 007c 0F92      		push r0
 160               	.LCFI12:
 161               		.cfi_def_cfa_offset 4
 162               		.cfi_offset 0, -3
 163 007e 0FB6      		in r0,__SREG__
 164 0080 0F92      		push r0
 165 0082 1124      		clr __zero_reg__
 166 0084 8F93      		push r24
 167               	.LCFI13:
 168               		.cfi_def_cfa_offset 5
 169               		.cfi_offset 24, -4
 170 0086 9F93      		push r25
 171               	.LCFI14:
 172               		.cfi_def_cfa_offset 6
 173               		.cfi_offset 25, -5
 174               	/* prologue: Signal */
 175               	/* frame size = 0 */
 176               	/* stack size = 5 */
 177               	.L__stack_usage = 5
  67:interrupts.c  **** 	TCNT1 = t1Offset;	// Reset the wakefulness timer, so the processor
 178               		.loc 1 67 0
 179 0088 8091 0000 		lds r24,t1Offset
 180 008c 9091 0000 		lds r25,t1Offset+1
 181 0090 9DBD      		out 0x2c+1,r25
 182 0092 8CBD      		out 0x2c,r24
  68:interrupts.c  **** 						//   doesn't go to sleep while the user is
  69:interrupts.c  **** 						//   interacting with it.
  70:interrupts.c  **** 	serialRxData = UDR; // Pass the data back to the main loop for parsing.
 183               		.loc 1 70 0
 184 0094 8CB1      		in r24,0xc
 185 0096 8093 0000 		sts serialRxData,r24
 186               	/* epilogue start */
  71:interrupts.c  **** }
 187               		.loc 1 71 0
 188 009a 9F91      		pop r25
 189 009c 8F91      		pop r24
 190 009e 0F90      		pop r0
 191 00a0 0FBE      		out __SREG__,r0
 192 00a2 0F90      		pop r0
 193 00a4 1F90      		pop r1
 194 00a6 1895      		reti
 195               		.cfi_endproc
 196               	.LFE3:
 198               	.Letext0:
 199               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 interrupts.c
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:2      *ABS*:0000003d __SP_L__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:3      *ABS*:0000003f __SREG__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:4      *ABS*:00000000 __tmp_reg__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:5      *ABS*:00000001 __zero_reg__
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:11     .text:00000000 __vector_5
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:51     .text:0000001e __vector_1
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:101    .text:0000004c __vector_2
/var/folders/jy/pkqnkk1s5x97h68j2fkh30vh0000gq/T//cckqBuEv.s:151    .text:0000007a USART_RX_vect

UNDEFINED SYMBOLS
sleepyTime
t1Offset
serialRxData
